{"version":3,"file":"sparky.js","sources":["../node_modules/nanoid/non-secure/index.js","../node_modules/mdn-polyfills/Array.from.js","../node_modules/mdn-polyfills/Array.prototype.find.js","../src/sparky.dom.ts","../src/polyfill/isConnected.ts","../src/sparky.eventmanager.ts","../node_modules/mdn-polyfills/String.prototype.startsWith.js","../src/sparky.helper.ts","../src/sparky.component.ts","../src/sparky.event.ts","../src/sparky.ts","../node_modules/requestidlecallback-polyfill/index.js","../src/sparky.function.ts","../src/sparky.ts"],"sourcesContent":["// This alphabet uses a-z A-Z 0-9 _- symbols.\n// Symbols are generated for smaller size.\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\nvar url = '-_'\n// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).\nvar i = 36\nwhile (i--) {\n  // 36 is radix. Number.prototype.toString(36) returns number\n  // in Base36 representation. Base36 is like hex, but it uses 0â€“9 and a-z.\n  url += i.toString(36)\n}\n// Loop from 36 to 10 (from Z to A in Base36).\ni = 36\nwhile (i-- - 10) {\n  url += i.toString(36).toUpperCase()\n}\n\n/**\n * Generate URL-friendly unique ID. This method use non-secure predictable\n * random generator with bigger collision probability.\n *\n * @param {number} [size=21] The number of symbols in ID.\n *\n * @return {string} Random string.\n *\n * @example\n * const nanoid = require('nanoid/non-secure')\n * model.id = nanoid() //=> \"Uakgb_J5m9g-0JDMbcJqL\"\n *\n * @name nonSecure\n * @function\n */\nmodule.exports = function (size) {\n  var id = ''\n  i = size || 21\n  // Compact alternative for `for (var i = 0; i < size; i++)`\n  while (i--) {\n    // `| 0` is compact and faster alternative for `Math.floor()`\n    id += url[Math.random() * 64 | 0]\n  }\n  return id\n}\n","!function(){var t,u,e,c;Array.from||(Array.from=(t=Object.prototype.toString,u=function(r){return\"function\"==typeof r||\"[object Function]\"===t.call(r)},e=Math.pow(2,53)-1,c=function(r){var t,n=(t=Number(r),isNaN(t)?0:0!==t&&isFinite(t)?(0<t?1:-1)*Math.floor(Math.abs(t)):t);return Math.min(Math.max(n,0),e)},function(r){var t=Object(r);if(null==r)throw new TypeError(\"Array.from requires an array-like object - not null or undefined\");var n,e=1<arguments.length?arguments[1]:void 0;if(void 0!==e){if(!u(e))throw new TypeError(\"Array.from: when provided, the second argument must be a function\");2<arguments.length&&(n=arguments[2])}for(var o,a=c(t.length),i=u(this)?Object(new this(a)):new Array(a),f=0;f<a;)o=t[f],i[f]=e?void 0===n?e(o,f):e.call(n,o,f):o,f+=1;return i.length=a,i}))}();\n","Array.prototype.find||(Array.prototype.find=function(r){if(null==this)throw new TypeError(\"Array.prototype.find called on null or undefined\");if(\"function\"!=typeof r)throw new TypeError(\"predicate must be a function\");for(var t=Object(this),n=t.length>>>0,o=arguments[1],e=void 0,i=0;i<n;i++)if(e=t[i],r.call(o,e,i,t))return e});\n","let currentDom: HTMLElement = null;\r\n\r\nexport function getCurrentDom() {\r\n    return currentDom;\r\n}\r\n\r\nexport function setCurrentDom(dom: HTMLElement) {\r\n    currentDom = dom;\r\n}\r\n\r\nexport function reconciliate(currentDom: HTMLElement, nextDom: HTMLElement) {\r\n    if (!nextDom) return null;\r\n    if (!currentDom && nextDom) return nextDom;\r\n    if (currentDom.isEqualNode(nextDom)) return currentDom;\r\n    if (currentDom.nodeName !== nextDom.nodeName) return nextDom;\r\n\r\n    const domQueue: [Node, Node][] = [[currentDom, nextDom]];\r\n\r\n    while(domQueue.length > 0) {\r\n        const [currentElem, nextElem] = domQueue.shift();\r\n        const removedList: Node[] = [];\r\n        reconciliateAttribute(currentElem as HTMLElement, nextElem as HTMLElement);\r\n\r\n        const nextElemChildren = nextElem.childNodes;\r\n        currentElem.childNodes.forEach((node, i) => {\r\n            const nextNode = nextElemChildren.item(i);\r\n\r\n            if(!nextNode) {\r\n                removedList.push(node)\r\n                return;\r\n            }\r\n\r\n            if(node.isEqualNode(nextNode)) return;\r\n\r\n            if(node.nodeName !== nextNode.nodeName) {\r\n                currentElem.replaceChild(nextNode.cloneNode(true), node);\r\n                return;\r\n            }\r\n\r\n            if(node.nodeName == \"#text\" && node.textContent !== nextNode.textContent) {\r\n                node.textContent = nextNode.textContent;\r\n                return;\r\n            }\r\n\r\n            domQueue.push([node, nextNode])\r\n        });\r\n\r\n        for(let i = currentElem.childNodes.length; i < nextElem.childNodes.length; i++) {\r\n            const childNode = nextElem.childNodes.item(i);\r\n            currentElem.appendChild(childNode.cloneNode(true))\r\n        }\r\n\r\n        removedList.forEach((rmElem) => {\r\n            currentElem.removeChild(rmElem)\r\n        })\r\n\r\n    }\r\n\r\n    return currentDom;\r\n}\r\n\r\nfunction reconciliateAttribute(currentElem: HTMLElement, nextElem: HTMLElement) {\r\n    if(!currentElem.attributes || !nextElem.attributes) return;\r\n\r\n    const sortedCurrentAttributes = Array.from(currentElem.attributes).sort((attr, attr2) => attributeSort(attr, attr2))\r\n    const sortedNextAttributes = Array.from(nextElem.attributes).sort((attr, attr2) => attributeSort(attr, attr2))\r\n\r\n    const removedAttr: Attr[] = [];\r\n\r\n    sortedCurrentAttributes.forEach((attr, i) => {\r\n        const nextAttr = sortedNextAttributes[i];\r\n\r\n        if(!nextAttr) {\r\n            removedAttr.push(attr);\r\n            return;\r\n        }\r\n        \r\n        if(attr.name !== nextAttr.name) {\r\n            removedAttr.push(attr);\r\n            currentElem.setAttribute(nextAttr.name, nextAttr.value);\r\n            return;\r\n        }\r\n\r\n        if(attr.value !== nextAttr.value) {\r\n            attr.value = nextAttr.value;\r\n        }\r\n    })\r\n\r\n    for(let i = sortedCurrentAttributes.length; i < sortedNextAttributes.length; i++) {\r\n        const nextAttr = sortedNextAttributes[i];\r\n        currentElem.setAttribute(nextAttr.name, nextAttr.value);\r\n    }\r\n\r\n    removedAttr.forEach(attr => currentElem.removeAttribute(attr.name))\r\n}\r\n\r\nfunction attributeSort(a: Attr, b: Attr) {\r\n    return (a.name < b.name ? -1 : (a.name > b.name ? 1 : 0));\r\n}\r\n","/*\r\n * Node.isConnected polyfill for IE and EdgeHTML\r\n * 2020-02-04\r\n *\r\n * By Eli Grey, https://eligrey.com\r\n * Public domain.\r\n * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\r\n */\r\nexport function isConnectedPolyfill() {\r\n    if (!('isConnected' in Node.prototype)) {\r\n        Object.defineProperty(Node.prototype, 'isConnected', {\r\n        get() {\r\n            return (\r\n            !this.ownerDocument ||\r\n            !(\r\n                this.ownerDocument.compareDocumentPosition(this) &\r\n                this.DOCUMENT_POSITION_DISCONNECTED\r\n            )\r\n            );\r\n        },\r\n        });\r\n    }    \r\n}\r\n","import { isConnectedPolyfill } from \"./polyfill/isConnected\"\r\n\r\nisConnectedPolyfill();\r\n\r\ninterface eventListSingle {\r\n    dom: HTMLElement;\r\n    type: string;\r\n    callbackFn: eventCallbackFn;\r\n}\r\n\r\ntype eventCallbackFn = (evt: Event) => void;\r\n\r\nexport class EventManager {\r\n    static oldEventType: string[] = [];\r\n    static eventList: eventListSingle[] = [];\r\n    static eventListType: string[] = [];\r\n\r\n    static listen() {\r\n        EventManager.removeUnusedEvents();\r\n        this.eventList.forEach((event) => {\r\n            const { type } = event;\r\n            if(!this.isEventTypeListening(type)) {\r\n                document.addEventListener(type, (event) => this.dispatchEvent(event))\r\n                this.eventListType.push(type);\r\n            }\r\n        });\r\n    }\r\n\r\n    static dispatchEvent(event: Event) {\r\n        this.eventList.find((evtList) => {\r\n            if(this.isEventTarget(evtList, event)) {\r\n                if(evtList.type === event.type) {\r\n                    evtList.callbackFn(event);\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    static addEvent(eventSingle: eventListSingle) {\r\n        const {dom, type, callbackFn} = eventSingle;\r\n        this.eventList.push({ dom, type, callbackFn });\r\n    }\r\n\r\n    private static removeUnusedEvents() {\r\n        this.eventList = this.eventList\r\n            .filter((evt) => evt.dom.isConnected);\r\n    }\r\n\r\n    private static isEventTypeListening(type: string) {\r\n        return this.eventListType.find(t => t == type);\r\n    }\r\n\r\n    private static isEventTarget(evtList: eventListSingle, event: Event) {\r\n        return (evtList.dom === event.target) || evtList.dom.contains(event.target as HTMLElement);\r\n    }\r\n}","String.prototype.startsWith||(String.prototype.startsWith=function(t,r){return r=r||0,this.substr(r,t.length)===t});\n","interface ISortArray {\r\n    bigArray: any[];\r\n    smallArray: any[];\r\n}\r\n\r\nexport function arrayAreSame(array1: any[], array2: any[]) {\r\n    const { bigArray, smallArray } = sortArrayInObject(array1, array2);\r\n\r\n    return bigArray.every((big, i) => {\r\n        return big == (smallArray ? smallArray[i] : null);\r\n    })\r\n}\r\n\r\nfunction sortArrayInObject(array1: any[], array2: any[]): ISortArray {\r\n    const length_1 = array1.length;\r\n    const length_2 = array2.length;\r\n\r\n    if(length_1 > length_2) return { bigArray: array1, smallArray: array2 }\r\n\r\n    return { bigArray: array2, smallArray: array1 }\r\n}\r\n\r\nexport interface ISparkySelf {\r\n    indexMemo: number;\r\n    indexUpdate: number;\r\n}\r\n\r\nexport const defaultSparkySelf = {\r\n    indexMemo: 0,\r\n    indexUpdate: 0\r\n}","import { IRenderReturn, ISparkyComponent } from \"./sparky\";\r\nimport { findEvent } from \"./sparky.event\";\r\nimport { EventManager } from \"./sparky.eventmanager\";\r\nimport { defaultSparkySelf } from \"./sparky.helper\";\r\n\r\ninterface ICachedComponent {\r\n    component: ISparkyComponent,\r\n    dom: HTMLElement\r\n}\r\n\r\nexport class SparkyComponent {\r\n    private static cachedComponent: ICachedComponent[][] = [];\r\n    static populate(render: IRenderReturn, rootComponent: ISparkyComponent) {\r\n        \r\n        const renderQueue = [render];\r\n\r\n        let depthHorizontal = 0;\r\n\r\n        while (renderQueue.length > 0) {\r\n            const currentRender = renderQueue.shift();\r\n            if(!this.cachedComponent[depthHorizontal]) this.cachedComponent[depthHorizontal] = [];\r\n\r\n            currentRender.func.forEach((currentFunc, index) => {\r\n                const currentEvent = findEvent(render.dom, currentRender.renderId, index);\r\n                const eventName = currentEvent.attr.name.replace(\"on\", \"\");\r\n                EventManager.addEvent({\r\n                    dom: currentEvent.dom,\r\n                    type: eventName,\r\n                    callbackFn: currentFunc.func.bind(window, event)\r\n                })\r\n                currentEvent.dom.removeAttribute(currentEvent.attr.name)\r\n            })\r\n\r\n            currentRender.children.forEach((currentChild) => {\r\n                renderQueue.push(currentChild)\r\n            })\r\n\r\n            currentRender.nestedComponents.forEach((currentComp, index) => {\r\n                if(currentComp.type !== \"SparkyComponent\") return;\r\n                const cached = this.cachedComponent[depthHorizontal][index];\r\n                const commentDom = this.findComment(render.dom, currentRender.renderId, index, currentComp.selfFn.name);\r\n                if(cached) {\r\n                    cached.component.self.props = currentComp.self.props;\r\n                    cached.component.self.__sparkySelf = {...defaultSparkySelf}\r\n                    currentComp = cached.component;\r\n                }\r\n                const renderChild = currentComp.selfFn(currentComp.self, Object.freeze(currentComp.self.props));\r\n                if(!commentDom) return;\r\n                commentDom.parentNode.replaceChild(renderChild.dom, commentDom);\r\n                currentComp.self.__root = rootComponent;\r\n                render.func.push(...renderChild.func);\r\n                renderQueue.push(renderChild);\r\n\r\n                this.cachedComponent[depthHorizontal].push({\r\n                    component: currentComp,\r\n                    dom: renderChild.dom\r\n                })\r\n            });\r\n            depthHorizontal++;\r\n        }\r\n\r\n        return render.dom;\r\n    }\r\n\r\n    private static findComment(element: HTMLElement, renderId: string, i: number, componentName: string) {\r\n        const domQueue = [element];\r\n        while(domQueue.length > 0) {\r\n            const elem = domQueue.shift();\r\n            if(elem.nodeName == '#comment' && elem.nodeValue.trim() == `SparkyComponent#${componentName}#${i}#${renderId}`) {\r\n                return elem;\r\n            }\r\n\r\n            Array.from(elem.childNodes as NodeListOf<HTMLElement>).forEach((child) => {\r\n                domQueue.push(child)\r\n            })\r\n        }\r\n    }\r\n}","import 'mdn-polyfills/String.prototype.startsWith';\r\n\r\ninterface IEventReturn {\r\n    dom: HTMLElement;\r\n    attr: Attr;\r\n}\r\n\r\nexport function findEvent(element: HTMLElement, renderId: string, index: number) : IEventReturn {\r\n    const domQueue = [element];\r\n    while(domQueue.length > 0) {\r\n        const elem = domQueue.shift();\r\n        const eventAttr = Array.from(elem.attributes).find((attr) => {\r\n            if(attr.name.startsWith(\"on\")) {\r\n                return attr.value == `SparkyFunction#${renderId}#${index}`;\r\n            }\r\n        })\r\n\r\n        if(eventAttr) return {dom: elem, attr: eventAttr};\r\n        \r\n        Array.from(elem.children as HTMLCollectionOf<HTMLElement>).forEach((child) => {\r\n            domQueue.push(child)\r\n        })\r\n    }\r\n}","import nanoid from \"nanoid/non-secure\";\r\n\r\nimport 'mdn-polyfills/Array.from';\r\nimport 'mdn-polyfills/Array.prototype.find';\r\n\r\nimport { SparkyFunction } from \"./sparky.function\";\r\nimport { reconciliate, getCurrentDom, setCurrentDom } from \"./sparky.dom\";\r\nimport { EventManager } from \"./sparky.eventmanager\";\r\nimport { SparkyComponent } from \"./sparky.component\";\r\nimport { defaultSparkySelf } from \"./sparky.helper\";\r\n\r\nimport { isConnectedPolyfill } from \"./polyfill/isConnected\"\r\n\r\n\r\nisConnectedPolyfill();\r\n\r\nexport interface IRenderReturn extends IReconciliateProps {\r\n    type: string;\r\n    nestedComponents: ISparkyComponent[];\r\n    children: IRenderReturn[];\r\n    renderId: string;\r\n}\r\n\r\nexport interface IReconciliateProps {\r\n    dom: HTMLElement,\r\n    func: ISparkyEventFunc[],\r\n}\r\n\r\nexport type ISelfFunction = (self: SparkyFunction, props?: any) => IRenderReturn;\r\n\r\nexport interface ISparkyEventFunc {\r\n    renderId: string;\r\n    index: number;\r\n    func: Function;\r\n}\r\n\r\nexport interface ISparkyComponent {\r\n    type: string;\r\n    self: SparkyFunction;\r\n    selfFn: ISelfFunction;\r\n}\r\n\r\nexport interface ISparkyProps {\r\n    [key: string]: any;\r\n}\r\n\r\nexport type ISparkyState = ISparkyProps;\r\n\r\nexport class Sparky {\r\n    public static _DEV_: boolean = true;\r\n\r\n    /**\r\n     * Generate a Sparky Component that can be mount.\r\n     * @param renderFunc The function that going to be execute to render html template\r\n     */\r\n    static component(renderFunc: ISelfFunction, props?: ISparkyProps) {\r\n        const thisFunction = new SparkyFunction(renderFunc, props);\r\n        thisFunction.__sparkySelf = { ...defaultSparkySelf };\r\n        return { type: \"SparkyComponent\", self: thisFunction, selfFn: renderFunc } as ISparkyComponent;\r\n    }\r\n\r\n    /**\r\n     * Mount a Sparky Component in the DOM Tree and keep it updated.\r\n     * @param component Sparky Component\r\n     * @param dom The dom element where you want to mount this component\r\n     */\r\n    static mount(component: ISparkyComponent, dom?: HTMLElement) {\r\n        if (Sparky._DEV_)\r\n            console.time();\r\n\r\n        const { self, selfFn } = component;\r\n        self.__sparkySelf = { ...defaultSparkySelf };\r\n        const render = selfFn(self, Object.freeze(self.props)) as IRenderReturn;\r\n\r\n        render.dom = SparkyComponent.populate(render, component);\r\n\r\n        let finalDOM = reconciliate(getCurrentDom(), render.dom);\r\n        if (!finalDOM) return;\r\n        if (!finalDOM.isConnected && dom)\r\n            dom.appendChild(finalDOM);\r\n        EventManager.listen();\r\n\r\n        setCurrentDom(finalDOM as HTMLElement);\r\n\r\n        if (Sparky._DEV_)\r\n            console.timeEnd();\r\n    }\r\n\r\n    /**\r\n     * Reconciliate the current DOM with the new DOM Node\r\n     * @param oldNode Node that need to be reconcile\r\n     * @param newNode Node that have the new elements\r\n     */\r\n    static reconciliate(oldNode: HTMLElement, newNode: HTMLElement) {\r\n        return reconciliate(oldNode, newNode)\r\n    }\r\n}\r\n\r\n/**\r\n * Render the html string template to HTML elements\r\n * @param html Array of HTML String \r\n * @param computedProps Computed Props used to pass Javascript into template\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals\r\n */\r\nexport function render(html: TemplateStringsArray | string, ...computedProps: any[]): IRenderReturn {\r\n    const domNode = document.createElement(\"div\");\r\n    const func: ISparkyEventFunc[] = [];\r\n    const nestedComponents: ISparkyComponent[] = [];\r\n    const children: IRenderReturn[] = [];\r\n    const renderId = nanoid(12);\r\n\r\n    const newHTML = (typeof html == \"string\") ? html\r\n        : html.map((stringHTML, i) => {\r\n            let htmlLine = \"\"\r\n            htmlLine += stringHTML\r\n            if (!computedProps[i]) return htmlLine;\r\n            htmlLine = getComputedValue(computedProps, i, func, htmlLine, nestedComponents, children, renderId);\r\n            return htmlLine;\r\n        })\r\n\r\n    domNode.innerHTML = Array.isArray(newHTML) ? newHTML.join(\"\") : newHTML;\r\n\r\n    if (domNode.children.length > 1) {\r\n        throw new TypeError(\"The render HTML can only had one root node\");\r\n    }\r\n\r\n    return { type: \"SparkyRender\", dom: domNode.firstElementChild as HTMLElement, func, nestedComponents, children, renderId };\r\n}\r\n\r\nfunction getComputedValue(computedProps: any[], i: number, func: ISparkyEventFunc[], htmlLine: string, nestedComponents: ISparkyComponent[], children: IRenderReturn[], renderId: string) {\r\n    if (typeof computedProps[i] == \"function\") {\r\n        func.push({ index: func.length - 1, renderId, func: computedProps[i] });\r\n        htmlLine += `'SparkyFunction#${renderId}#${func.length - 1}'`;\r\n    }\r\n    else if (computedProps[i].type == \"SparkyRender\") {\r\n        const render = computedProps[i] as IRenderReturn;\r\n        htmlLine = renderSparkyObject(render, htmlLine);\r\n        children.push(render)\r\n    }\r\n    else if (computedProps[i].type == \"SparkyComponent\") {\r\n        const comp = computedProps[i] as ISparkyComponent;\r\n        htmlLine += `<!-- SparkyComponent#${comp.selfFn.name}#${nestedComponents.length}#${renderId} -->`;\r\n        nestedComponents.push(comp);\r\n    }\r\n    else {\r\n\r\n        computedProps[i] = Array.isArray(computedProps[i]) ?\r\n            computedProps[i].join(\"\") : new String(computedProps[i]);\r\n        if ((computedProps[i] as string).startsWith(\"<\"))\r\n            htmlLine += computedProps[i];\r\n        else\r\n            htmlLine += `<span class='computed'>${computedProps[i]}</span>`;\r\n    }\r\n    return htmlLine;\r\n}\r\n\r\nfunction renderSparkyObject(render: IRenderReturn, htmlLine: string) {\r\n    const div = document.createElement(\"div\");\r\n    div.appendChild(render.dom);\r\n    htmlLine += div.innerHTML;\r\n    return htmlLine;\r\n}\r\n","window.requestIdleCallback =\n    window.requestIdleCallback ||\n    function(cb) {\n        var start = Date.now();\n        return setTimeout(function() {\n            cb({\n                didTimeout: false,\n                timeRemaining: function() {\n                    return Math.max(0, 50 - (Date.now() - start));\n                },\n            });\n        }, 1);\n    };\n\nwindow.cancelIdleCallback =\n    window.cancelIdleCallback ||\n    function(id) {\n        clearTimeout(id);\n    };\n","import { Sparky, IRenderReturn, ISparkyComponent, ISparkyProps, ISparkyState } from \"./sparky\";\r\nimport 'requestidlecallback-polyfill';\r\nimport { arrayAreSame, ISparkySelf } from \"./sparky.helper\";\r\n\r\ntype CachedType = \"memoize\" | \"update\";\r\ntype UpdateCallback = () => void;\r\ntype ArgumentsList = any[];\r\n\r\ninterface IFnCached {\r\n    fn: Function;\r\n    dependencies: string[];\r\n    result: any;\r\n}\r\n\r\nexport class SparkyFunction {\r\n    public __root: ISparkyComponent;\r\n    public __sparkySelf: ISparkySelf;\r\n    public props: ISparkyProps;\r\n    \r\n    private cachedUpdate: IFnCached[] = [];\r\n    private cachedMemo: IFnCached[] = [];\r\n    private state: ISparkyState;\r\n    private renderFunc: (self: SparkyFunction) => IRenderReturn;\r\n\r\n    constructor(renderFunc: (self: SparkyFunction) => IRenderReturn, props: ISparkyProps) {\r\n        this.props = Object.freeze(props || {});\r\n        this.state = {};\r\n        this.renderFunc = renderFunc;\r\n        this.__root = null;\r\n    }\r\n    \r\n    /**\r\n     * Execute after the render/update of the DOM tree.\r\n     * @param callback - The function that you want to execute\r\n     * @param dependenciesChanged - An array of keys to know when the onUpdate need to be executed\r\n     */\r\n    onUpdate = (callback: UpdateCallback, dependenciesChanged?: ArgumentsList) => {\r\n        window.requestIdleCallback(() => {\r\n            callCachedFn(this, \"update\", this.cachedUpdate, callback, dependenciesChanged)\r\n        }, { timeout: 250 });\r\n    }\r\n\r\n    /**\r\n    * Get State object value of this context\r\n    * @param props - the specific key of the value that you want to retrieve\r\n    */\r\n    getState = <S>(props: string): S => {\r\n        if (props) return this.state[props];\r\n        return this.state as S;\r\n    }\r\n\r\n    /**\r\n     * Add/Set a new value into the State object of the context\r\n     * @param newState - new Value\r\n     */\r\n    setState = <S>(newState: S) => {\r\n        this.state = { ...this.state, ...newState };\r\n        (this.__root) ? Sparky.mount(this.__root) :\r\n            Sparky.mount({ type: \"SparkyComponent\", self: this, selfFn: this.renderFunc });\r\n    }\r\n\r\n    /**\r\n     * Call the function callback only when dependencies has changed\r\n     * @param callbackFn - Callback to be called when needed\r\n     * @param argumentsChanged - list of value that are used to know if the callback needed to be recalled\r\n     */\r\n    memoize = (callbackFn: Function, argumentsChanged?: ArgumentsList) => {\r\n        callCachedFn(this, \"memoize\", this.cachedMemo, callbackFn, argumentsChanged)\r\n    }\r\n}\r\n\r\nfunction callCachedFn(self: SparkyFunction, type: CachedType,cachedArray: IFnCached[], callbackFn: Function, argumentsChanged?: ArgumentsList) {\r\n    const fnCached = cachedArray[getIndexByType(self, type)];\r\n    incrementIndexByType(self, type)\r\n\r\n    const newMemo = {\r\n        fn: callbackFn,\r\n        result: null,\r\n        dependencies: argumentsChanged\r\n    };\r\n\r\n    if(!fnCached || !argumentsChanged) {\r\n        newMemo.result = callbackFn.call(window, argumentsChanged ? [ ...argumentsChanged ] : null);\r\n        cachedArray.push(newMemo)\r\n        return newMemo.result;\r\n    }\r\n    \r\n    if(!arrayAreSame(fnCached.dependencies, argumentsChanged)) {\r\n        fnCached.dependencies = argumentsChanged;\r\n        fnCached.result = callbackFn.call(window, ...argumentsChanged);\r\n        return fnCached.result;\r\n    }\r\n    \r\n    return fnCached.result;\r\n}\r\n\r\nfunction getIndexByType(self: SparkyFunction, type: CachedType) {\r\n    if(type == \"memoize\")\r\n        return self.__sparkySelf.indexMemo;\r\n    return self.__sparkySelf.indexUpdate;\r\n}\r\nfunction incrementIndexByType(self: SparkyFunction, type: CachedType) {\r\n    if(type == \"memoize\")\r\n        return ++self.__sparkySelf.indexMemo;\r\n    return ++self.__sparkySelf.indexUpdate;    \r\n}","import nanoid from \"nanoid/non-secure\";\r\n\r\nimport 'mdn-polyfills/Array.from';\r\nimport 'mdn-polyfills/Array.prototype.find';\r\n\r\nimport { SparkyFunction } from \"./sparky.function\";\r\nimport { reconciliate, getCurrentDom, setCurrentDom } from \"./sparky.dom\";\r\nimport { EventManager } from \"./sparky.eventmanager\";\r\nimport { SparkyComponent } from \"./sparky.component\";\r\nimport { defaultSparkySelf } from \"./sparky.helper\";\r\n\r\nimport { isConnectedPolyfill } from \"./polyfill/isConnected\"\r\n\r\n\r\nisConnectedPolyfill();\r\n\r\nexport interface IRenderReturn extends IReconciliateProps {\r\n    type: string;\r\n    nestedComponents: ISparkyComponent[];\r\n    children: IRenderReturn[];\r\n    renderId: string;\r\n}\r\n\r\nexport interface IReconciliateProps {\r\n    dom: HTMLElement,\r\n    func: ISparkyEventFunc[],\r\n}\r\n\r\nexport type ISelfFunction = (self: SparkyFunction, props?: any) => IRenderReturn;\r\n\r\nexport interface ISparkyEventFunc {\r\n    renderId: string;\r\n    index: number;\r\n    func: Function;\r\n}\r\n\r\nexport interface ISparkyComponent {\r\n    type: string;\r\n    self: SparkyFunction;\r\n    selfFn: ISelfFunction;\r\n}\r\n\r\nexport interface ISparkyProps {\r\n    [key: string]: any;\r\n}\r\n\r\nexport type ISparkyState = ISparkyProps;\r\n\r\nexport class Sparky {\r\n    public static _DEV_: boolean = true;\r\n\r\n    /**\r\n     * Generate a Sparky Component that can be mount.\r\n     * @param renderFunc The function that going to be execute to render html template\r\n     */\r\n    static component(renderFunc: ISelfFunction, props?: ISparkyProps) {\r\n        const thisFunction = new SparkyFunction(renderFunc, props);\r\n        thisFunction.__sparkySelf = { ...defaultSparkySelf };\r\n        return { type: \"SparkyComponent\", self: thisFunction, selfFn: renderFunc } as ISparkyComponent;\r\n    }\r\n\r\n    /**\r\n     * Mount a Sparky Component in the DOM Tree and keep it updated.\r\n     * @param component Sparky Component\r\n     * @param dom The dom element where you want to mount this component\r\n     */\r\n    static mount(component: ISparkyComponent, dom?: HTMLElement) {\r\n        if (Sparky._DEV_)\r\n            console.time();\r\n\r\n        const { self, selfFn } = component;\r\n        self.__sparkySelf = { ...defaultSparkySelf };\r\n        const render = selfFn(self, Object.freeze(self.props)) as IRenderReturn;\r\n\r\n        render.dom = SparkyComponent.populate(render, component);\r\n\r\n        let finalDOM = reconciliate(getCurrentDom(), render.dom);\r\n        if (!finalDOM) return;\r\n        if (!finalDOM.isConnected && dom)\r\n            dom.appendChild(finalDOM);\r\n        EventManager.listen();\r\n\r\n        setCurrentDom(finalDOM as HTMLElement);\r\n\r\n        if (Sparky._DEV_)\r\n            console.timeEnd();\r\n    }\r\n\r\n    /**\r\n     * Reconciliate the current DOM with the new DOM Node\r\n     * @param oldNode Node that need to be reconcile\r\n     * @param newNode Node that have the new elements\r\n     */\r\n    static reconciliate(oldNode: HTMLElement, newNode: HTMLElement) {\r\n        return reconciliate(oldNode, newNode)\r\n    }\r\n}\r\n\r\n/**\r\n * Render the html string template to HTML elements\r\n * @param html Array of HTML String \r\n * @param computedProps Computed Props used to pass Javascript into template\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals\r\n */\r\nexport function render(html: TemplateStringsArray | string, ...computedProps: any[]): IRenderReturn {\r\n    const domNode = document.createElement(\"div\");\r\n    const func: ISparkyEventFunc[] = [];\r\n    const nestedComponents: ISparkyComponent[] = [];\r\n    const children: IRenderReturn[] = [];\r\n    const renderId = nanoid(12);\r\n\r\n    const newHTML = (typeof html == \"string\") ? html\r\n        : html.map((stringHTML, i) => {\r\n            let htmlLine = \"\"\r\n            htmlLine += stringHTML\r\n            if (!computedProps[i]) return htmlLine;\r\n            htmlLine = getComputedValue(computedProps, i, func, htmlLine, nestedComponents, children, renderId);\r\n            return htmlLine;\r\n        })\r\n\r\n    domNode.innerHTML = Array.isArray(newHTML) ? newHTML.join(\"\") : newHTML;\r\n\r\n    if (domNode.children.length > 1) {\r\n        throw new TypeError(\"The render HTML can only had one root node\");\r\n    }\r\n\r\n    return { type: \"SparkyRender\", dom: domNode.firstElementChild as HTMLElement, func, nestedComponents, children, renderId };\r\n}\r\n\r\nfunction getComputedValue(computedProps: any[], i: number, func: ISparkyEventFunc[], htmlLine: string, nestedComponents: ISparkyComponent[], children: IRenderReturn[], renderId: string) {\r\n    if (typeof computedProps[i] == \"function\") {\r\n        func.push({ index: func.length - 1, renderId, func: computedProps[i] });\r\n        htmlLine += `'SparkyFunction#${renderId}#${func.length - 1}'`;\r\n    }\r\n    else if (computedProps[i].type == \"SparkyRender\") {\r\n        const render = computedProps[i] as IRenderReturn;\r\n        htmlLine = renderSparkyObject(render, htmlLine);\r\n        children.push(render)\r\n    }\r\n    else if (computedProps[i].type == \"SparkyComponent\") {\r\n        const comp = computedProps[i] as ISparkyComponent;\r\n        htmlLine += `<!-- SparkyComponent#${comp.selfFn.name}#${nestedComponents.length}#${renderId} -->`;\r\n        nestedComponents.push(comp);\r\n    }\r\n    else {\r\n\r\n        computedProps[i] = Array.isArray(computedProps[i]) ?\r\n            computedProps[i].join(\"\") : new String(computedProps[i]);\r\n        if ((computedProps[i] as string).startsWith(\"<\"))\r\n            htmlLine += computedProps[i];\r\n        else\r\n            htmlLine += `<span class='computed'>${computedProps[i]}</span>`;\r\n    }\r\n    return htmlLine;\r\n}\r\n\r\nfunction renderSparkyObject(render: IRenderReturn, htmlLine: string) {\r\n    const div = document.createElement(\"div\");\r\n    div.appendChild(render.dom);\r\n    htmlLine += div.innerHTML;\r\n    return htmlLine;\r\n}\r\n"],"names":["url","i","toString","toUpperCase","t","u","e","c","Array","from","Object","prototype","r","call","Math","pow","n","Number","isNaN","isFinite","floor","abs","min","max","TypeError","arguments","length","o","a","this","f","find","currentDom","getCurrentDom","setCurrentDom","dom","reconciliate","nextDom","isEqualNode","nodeName","domQueue","_a","currentElem","nextElem","removedList","attributes","sortedCurrentAttributes","sort","attr","attr2","attributeSort","sortedNextAttributes","removedAttr","forEach","nextAttr","name","push","setAttribute","value","removeAttribute","reconciliateAttribute","nextElemChildren","childNodes","node","nextNode","item","textContent","replaceChild","cloneNode","childNode","appendChild","rmElem","removeChild","b","isConnectedPolyfill","Node","defineProperty","get","ownerDocument","compareDocumentPosition","DOCUMENT_POSITION_DISCONNECTED","EventManager","removeUnusedEvents","eventList","event","type","_this","isEventTypeListening","document","addEventListener","dispatchEvent","eventListType","evtList","isEventTarget","callbackFn","eventSingle","filter","evt","isConnected","target","contains","String","startsWith","substr","defaultSparkySelf","indexMemo","indexUpdate","SparkyComponent","render","rootComponent","renderQueue","depthHorizontal","currentRender","shift","this_1","cachedComponent","func","currentFunc","index","currentEvent","element","renderId","elem","eventAttr","children","child","findEvent","eventName","replace","addEvent","bind","window","currentChild","nestedComponents","currentComp","cached","commentDom","findComment","selfFn","component","self","props","__sparkySelf","renderChild","freeze","parentNode","__root","componentName","nodeValue","trim","Sparky","renderFunc","thisFunction","SparkyFunction","_DEV_","console","time","populate","finalDOM","listen","timeEnd","oldNode","newNode","requestIdleCallback","cb","start","Date","now","setTimeout","didTimeout","timeRemaining","cancelIdleCallback","id","clearTimeout","callback","dependenciesChanged","callCachedFn","cachedUpdate","timeout","state","newState","mount","argumentsChanged","cachedMemo","cachedArray","fnCached","array1","array2","length_1","smallArray","newMemo","fn","result","dependencies","bigArray","every","big","html","_i","computedProps","domNode","createElement","size","random","nanoid","newHTML","map","stringHTML","htmlLine","render_1","div","innerHTML","renderSparkyObject","comp","isArray","join","getComputedValue","firstElementChild"],"mappings":"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"}