{"version":3,"file":"sparky.js","sources":["../node_modules/nanoid/non-secure/index.js","../node_modules/mdn-polyfills/Array.from.js","../src/sparky.dom.ts","../src/polyfill/isConnected.ts","../node_modules/mdn-polyfills/Array.prototype.find.js","../src/sparky.eventmanager.ts","../node_modules/kind-of/index.js","../node_modules/is-plain-object/index.js","../node_modules/isobject/index.js","../node_modules/shallow-clone/index.js","../node_modules/clone-deep/index.js","../src/sparky.context.ts","../src/sparky.function.helper.ts","../src/sparky.helper.ts","../src/sparky.router.ts","../node_modules/requestidlecallback-polyfill/index.js","../src/sparky.function.ts","../src/sparky.ts","../node_modules/mdn-polyfills/String.prototype.startsWith.js","../src/sparky.component.ts","../src/sparky.event.ts","../src/sparky.ts"],"sourcesContent":["// This alphabet uses a-z A-Z 0-9 _- symbols.\n// Symbols are generated for smaller size.\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\nvar url = '-_'\n// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).\nvar i = 36\nwhile (i--) {\n  // 36 is radix. Number.prototype.toString(36) returns number\n  // in Base36 representation. Base36 is like hex, but it uses 0â€“9 and a-z.\n  url += i.toString(36)\n}\n// Loop from 36 to 10 (from Z to A in Base36).\ni = 36\nwhile (i-- - 10) {\n  url += i.toString(36).toUpperCase()\n}\n\n/**\n * Generate URL-friendly unique ID. This method use non-secure predictable\n * random generator with bigger collision probability.\n *\n * @param {number} [size=21] The number of symbols in ID.\n *\n * @return {string} Random string.\n *\n * @example\n * const nanoid = require('nanoid/non-secure')\n * model.id = nanoid() //=> \"Uakgb_J5m9g-0JDMbcJqL\"\n *\n * @name nonSecure\n * @function\n */\nmodule.exports = function (size) {\n  var id = ''\n  i = size || 21\n  // Compact alternative for `for (var i = 0; i < size; i++)`\n  while (i--) {\n    // `| 0` is compact and faster alternative for `Math.floor()`\n    id += url[Math.random() * 64 | 0]\n  }\n  return id\n}\n","!function(){var t,u,e,c;Array.from||(Array.from=(t=Object.prototype.toString,u=function(r){return\"function\"==typeof r||\"[object Function]\"===t.call(r)},e=Math.pow(2,53)-1,c=function(r){var t,n=(t=Number(r),isNaN(t)?0:0!==t&&isFinite(t)?(0<t?1:-1)*Math.floor(Math.abs(t)):t);return Math.min(Math.max(n,0),e)},function(r){var t=Object(r);if(null==r)throw new TypeError(\"Array.from requires an array-like object - not null or undefined\");var n,e=1<arguments.length?arguments[1]:void 0;if(void 0!==e){if(!u(e))throw new TypeError(\"Array.from: when provided, the second argument must be a function\");2<arguments.length&&(n=arguments[2])}for(var o,a=c(t.length),i=u(this)?Object(new this(a)):new Array(a),f=0;f<a;)o=t[f],i[f]=e?void 0===n?e(o,f):e.call(n,o,f):o,f+=1;return i.length=a,i}))}();\n","import { HTMLElementSparkyEnhanced } from \"./sparky.component\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function reconciliate(currentDom: HTMLElement, nextDom: HTMLElement) {\r\n    if (!nextDom) return null;\r\n    if (!currentDom && nextDom) return nextDom;\r\n    if (currentDom.isEqualNode(nextDom)) return currentDom;\r\n    if (currentDom.nodeName !== nextDom.nodeName) return nextDom;\r\n\r\n    const domQueue: [Node, Node][] = [[currentDom, nextDom]];\r\n\r\n    while(domQueue.length > 0) {\r\n        const [currentElem, nextElem] = domQueue.shift();\r\n        const removedList: Node[] = [];\r\n        reconciliateAttribute(currentElem as HTMLElement, nextElem as HTMLElement);\r\n        \r\n        if(nextElem.nodeName != \"#text\" && (nextElem as HTMLElementSparkyEnhanced).__sparkyEvent) {\r\n            (currentElem as HTMLElementSparkyEnhanced).__sparkyEvent = \r\n                (nextElem as HTMLElementSparkyEnhanced).__sparkyEvent;\r\n        }\r\n\r\n        if(nextElem.nodeName != \"#text\" && (nextElem as HTMLElementSparkyEnhanced).__sparkyRoot) {\r\n            (currentElem as HTMLElementSparkyEnhanced).__sparkyRoot = \r\n                (nextElem as HTMLElementSparkyEnhanced).__sparkyRoot;\r\n        }\r\n\r\n        const nextElemChildren = nextElem.childNodes;\r\n        currentElem.childNodes.forEach((node, i) => {\r\n            const nextNode = nextElemChildren.item(i) as HTMLElementSparkyEnhanced;\r\n\r\n            if(!nextNode) {\r\n                removedList.push(node)\r\n                return;\r\n            }\r\n\r\n            if(node.isEqualNode(nextNode)) return;\r\n\r\n            if(node.nodeName !== nextNode.nodeName) {\r\n                const newNextNode = nextNode.cloneNode(true);\r\n                const oldNextNode = nextNode.parentElement.replaceChild(newNextNode, nextNode);\r\n                currentElem.replaceChild(oldNextNode, node);\r\n                return;\r\n            }\r\n\r\n            if(node.nodeName == \"#text\" && node.textContent !== nextNode.textContent) {\r\n                node.textContent = nextNode.textContent;\r\n                return;\r\n            }\r\n\r\n            domQueue.push([node, nextNode])\r\n        });\r\n\r\n        for(let i = currentElem.childNodes.length; i < nextElem.childNodes.length; i++) {\r\n            const childNode = nextElem.childNodes.item(i);\r\n            const newNextNode = childNode.cloneNode(true);\r\n            const oldNextNode = childNode.parentElement.replaceChild(newNextNode, childNode);\r\n            currentElem.appendChild(oldNextNode)\r\n        }\r\n\r\n        removedList.forEach((rmElem) => {\r\n            currentElem.removeChild(rmElem)\r\n        })\r\n\r\n    }\r\n\r\n    return currentDom;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction reconciliateAttribute(currentElem: HTMLElement, nextElem: HTMLElement) {\r\n    if(!currentElem.attributes || !nextElem.attributes) return;\r\n\r\n    const sortedCurrentAttributes = Array.from(currentElem.attributes).sort((attr, attr2) => attributeSort(attr, attr2))\r\n    const sortedNextAttributes = Array.from(nextElem.attributes).sort((attr, attr2) => attributeSort(attr, attr2))\r\n\r\n    const removedAttr: Attr[] = [];\r\n\r\n    sortedCurrentAttributes.forEach((attr, i) => {\r\n        const nextAttr = sortedNextAttributes[i];\r\n\r\n        if(!nextAttr) {\r\n            removedAttr.push(attr);\r\n            return;\r\n        }\r\n        \r\n        if(attr.name !== nextAttr.name) {\r\n            removedAttr.push(attr);\r\n            currentElem.setAttribute(nextAttr.name, nextAttr.value);\r\n            return;\r\n        }\r\n\r\n        if(attr.value !== nextAttr.value) {\r\n            attr.value = nextAttr.value;\r\n        }\r\n    })\r\n\r\n    for(let i = sortedCurrentAttributes.length; i < sortedNextAttributes.length; i++) {\r\n        const nextAttr = sortedNextAttributes[i];\r\n        currentElem.setAttribute(nextAttr.name, nextAttr.value);\r\n    }\r\n\r\n    removedAttr.forEach(attr => currentElem.removeAttribute(attr.name))\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction attributeSort(a: Attr, b: Attr) {\r\n    return (a.name < b.name ? -1 : (a.name > b.name ? 1 : 0));\r\n}\r\n","/*\r\n * Node.isConnected polyfill for IE and EdgeHTML\r\n * 2020-02-04\r\n *\r\n * By Eli Grey, https://eligrey.com\r\n * Public domain.\r\n * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\r\n */\r\n/**@internal */\r\ndeclare var thisTest;\r\n/**\r\n * @internal\r\n */\r\nexport function isConnectedPolyfill() {\r\n    if (!('isConnected' in Node.prototype) || (typeof (window as any).test != \"undefined\")) {\r\n        Object.defineProperty(Node.prototype, 'isConnected', {\r\n        get() {\r\n            return (\r\n            !this.ownerDocument ||\r\n            !(\r\n                this.ownerDocument.compareDocumentPosition(this) &\r\n                this.DOCUMENT_POSITION_DISCONNECTED\r\n            )\r\n            );\r\n        },\r\n        });\r\n    }    \r\n}\r\n","Array.prototype.find||(Array.prototype.find=function(r){if(null==this)throw new TypeError(\"Array.prototype.find called on null or undefined\");if(\"function\"!=typeof r)throw new TypeError(\"predicate must be a function\");for(var t=Object(this),n=t.length>>>0,o=arguments[1],e=void 0,i=0;i<n;i++)if(e=t[i],r.call(o,e,i,t))return e});\n","import { isConnectedPolyfill } from \"./polyfill/isConnected\"\r\nimport { ISparkySelf } from \"./sparky.context\";\r\nimport { HTMLElementSparkyEnhanced } from \"./sparky.component\";\r\n\r\nisConnectedPolyfill();\r\n\r\n/**\r\n * @internal\r\n */\r\ninterface windowTesting extends Window {\r\n    thisTestEvent: eventListSingle[]\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface eventListSingle {\r\n    dom: HTMLElement;\r\n    type: string;\r\n    context: ISparkySelf;\r\n    callbackFn: eventCallbackFn;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface IEventSingle {\r\n    type: string;\r\n    context: ISparkySelf;\r\n    callbackFn: eventCallbackFn;\r\n}\r\n\r\n\r\n/**\r\n * @internal\r\n */\r\nexport type eventCallbackFn = (evt: Event) => void;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class EventManager {\r\n    static oldEventType: string[] = [];\r\n    static eventList: eventListSingle[] = [];\r\n    static eventListType: string[] = [];\r\n\r\n    static listen(finalDOM: HTMLElement) {\r\n        EventManager.removeAllEvents();\r\n        EventManager.populateEvents(finalDOM);\r\n        EventManager.removeUnusedEvents();\r\n        (window as unknown as windowTesting).thisTestEvent = EventManager.eventList;\r\n        this.eventList.forEach((event) => {\r\n            const { type } = event;\r\n            if(!this.isEventTypeListening(type)) {\r\n                document.addEventListener(type, (event) => this.dispatchEvent(event))\r\n                this.eventListType.push(type);\r\n            }\r\n        });\r\n    }\r\n\r\n    static dispatchEvent(event: Event) {\r\n        this.eventList.find((evtList) => {\r\n            if(this.isEventTarget(evtList, event)) {\r\n                if(evtList.type === event.type) {\r\n                    evtList.callbackFn(event);\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    static addEvent(eventSingle: eventListSingle) {\r\n        const {dom, type, context, callbackFn} = eventSingle;\r\n        this.eventList.push({ dom, type, context, callbackFn });\r\n    }\r\n\r\n    private static populateEvents(finalDOM: HTMLElementSparkyEnhanced) {\r\n        const domQueue = [finalDOM];\r\n        while(domQueue.length > 0) {\r\n            const elem = domQueue.shift();\r\n            \r\n            if(elem.__sparkyEvent) {\r\n                const { callbackFn, type, context } = elem.__sparkyEvent;\r\n                this.addEvent({dom: elem, type, context, callbackFn});\r\n            }\r\n    \r\n            for(let index = 0; index < elem.children.length; index++) {\r\n                domQueue.push(elem.children[index] as HTMLElement)\r\n            }\r\n        }\r\n    }\r\n\r\n    private static removeAllEvents() {\r\n        this.eventList = [];\r\n    }\r\n\r\n    private static removeUnusedEvents() {\r\n        this.eventList = this.eventList\r\n            .filter((evt) => evt.dom.isConnected);\r\n    }\r\n\r\n    private static isEventTypeListening(type: string) {\r\n        return this.eventListType.find(t => t == type);\r\n    }\r\n\r\n    private static isEventTarget(evtList: eventListSingle, event: Event) {\r\n        return (evtList.dom === event.target) || evtList.dom.contains(event.target as HTMLElement);\r\n    }\r\n}","var toString = Object.prototype.toString;\n\nmodule.exports = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol': return 'symbol';\n    case 'Promise': return 'promise';\n\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap': return 'weakmap';\n    case 'WeakSet': return 'weakset';\n    case 'Map': return 'map';\n    case 'Set': return 'set';\n\n    // 8-bit typed arrays\n    case 'Int8Array': return 'int8array';\n    case 'Uint8Array': return 'uint8array';\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\n\n    // 16-bit typed arrays\n    case 'Int16Array': return 'int16array';\n    case 'Uint16Array': return 'uint16array';\n\n    // 32-bit typed arrays\n    case 'Int32Array': return 'int32array';\n    case 'Uint32Array': return 'uint32array';\n    case 'Float32Array': return 'float32array';\n    case 'Float64Array': return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]': return 'object';\n    // iterators\n    case '[object Map Iterator]': return 'mapiterator';\n    case '[object Set Iterator]': return 'setiterator';\n    case '[object String Iterator]': return 'stringiterator';\n    case '[object Array Iterator]': return 'arrayiterator';\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return typeof val.constructor === 'function' ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function'\n    && typeof val.getDate === 'function'\n    && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string'\n    && typeof val.ignoreCase === 'boolean'\n    && typeof val.multiline === 'boolean'\n    && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function'\n    && typeof val.return === 'function'\n    && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nvar isObject = require('isobject');\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nmodule.exports = function isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n};\n","/*!\n * shallow-clone <https://github.com/jonschlinkert/shallow-clone>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst valueOf = Symbol.prototype.valueOf;\nconst typeOf = require('kind-of');\n\nfunction clone(val, deep) {\n  switch (typeOf(val)) {\n    case 'array':\n      return val.slice();\n    case 'object':\n      return Object.assign({}, val);\n    case 'date':\n      return new val.constructor(Number(val));\n    case 'map':\n      return new Map(val);\n    case 'set':\n      return new Set(val);\n    case 'buffer':\n      return cloneBuffer(val);\n    case 'symbol':\n      return cloneSymbol(val);\n    case 'arraybuffer':\n      return cloneArrayBuffer(val);\n    case 'float32array':\n    case 'float64array':\n    case 'int16array':\n    case 'int32array':\n    case 'int8array':\n    case 'uint16array':\n    case 'uint32array':\n    case 'uint8clampedarray':\n    case 'uint8array':\n      return cloneTypedArray(val);\n    case 'regexp':\n      return cloneRegExp(val);\n    case 'error':\n      return Object.create(val);\n    default: {\n      return val;\n    }\n  }\n}\n\nfunction cloneRegExp(val) {\n  const flags = val.flags !== void 0 ? val.flags : (/\\w+$/.exec(val) || void 0);\n  const re = new val.constructor(val.source, flags);\n  re.lastIndex = val.lastIndex;\n  return re;\n}\n\nfunction cloneArrayBuffer(val) {\n  const res = new val.constructor(val.byteLength);\n  new Uint8Array(res).set(new Uint8Array(val));\n  return res;\n}\n\nfunction cloneTypedArray(val, deep) {\n  return new val.constructor(val.buffer, val.byteOffset, val.length);\n}\n\nfunction cloneBuffer(val) {\n  const len = val.length;\n  const buf = Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : Buffer.from(len);\n  val.copy(buf);\n  return buf;\n}\n\nfunction cloneSymbol(val) {\n  return valueOf ? Object(valueOf.call(val)) : {};\n}\n\n/**\n * Expose `clone`\n */\n\nmodule.exports = clone;\n","'use strict';\n\n/**\n * Module dependenices\n */\n\nconst clone = require('shallow-clone');\nconst typeOf = require('kind-of');\nconst isPlainObject = require('is-plain-object');\n\nfunction cloneDeep(val, instanceClone) {\n  switch (typeOf(val)) {\n    case 'object':\n      return cloneObjectDeep(val, instanceClone);\n    case 'array':\n      return cloneArrayDeep(val, instanceClone);\n    default: {\n      return clone(val);\n    }\n  }\n}\n\nfunction cloneObjectDeep(val, instanceClone) {\n  if (typeof instanceClone === 'function') {\n    return instanceClone(val);\n  }\n  if (instanceClone || isPlainObject(val)) {\n    const res = new val.constructor();\n    for (let key in val) {\n      res[key] = cloneDeep(val[key], instanceClone);\n    }\n    return res;\n  }\n  return val;\n}\n\nfunction cloneArrayDeep(val, instanceClone) {\n  const res = new val.constructor(val.length);\n  for (let i = 0; i < val.length; i++) {\n    res[i] = cloneDeep(val[i], instanceClone);\n  }\n  return res;\n}\n\n/**\n * Expose `cloneDeep`\n */\n\nmodule.exports = cloneDeep;\n","import nanoid from \"nanoid/non-secure\";\r\nimport cloneDeep from \"clone-deep\";\r\nimport { ISparkyProps, ISparkyState, ISparkyComponent, IRenderReturn } from \"./sparky\";\r\nimport { IFnCached } from \"./sparky.function\";\r\nimport { HTMLElementSparkyEnhanced } from \"./sparky.component\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface ISparkySelf {\r\n    props: ISparkyProps;\r\n    state?: ISparkyState;\r\n    cachedMemo?: IFnCached[],\r\n    cachedUpdate?: IFnCached[],\r\n    cachedState?: any[]\r\n    indexes?: {\r\n        memo: number;\r\n        update: number;\r\n        state: number;\r\n        [x: string] : number;\r\n    },\r\n    __id?: string,\r\n    __root?: ISparkyComponent,\r\n    __rootElement?: HTMLElementSparkyEnhanced\r\n    renderFunc: (props?: any) => IRenderReturn;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nconst emptyContext: ISparkySelf = {\r\n    __rootElement: null,\r\n    __root: null,\r\n    __id: \"\",\r\n    props: {},\r\n    state: {},\r\n    cachedMemo: [],\r\n    cachedUpdate: [],\r\n    cachedState: [],\r\n    indexes: {\r\n        memo: 0,\r\n        update: 0,\r\n        state: 0\r\n    },\r\n    renderFunc: null\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class SparkyContext {\r\n    private static __context: ISparkySelf\r\n    private static __defaultContext : ISparkySelf = emptyContext\r\n\r\n    public static getCurrentContext() {\r\n        return this.__context;\r\n    }\r\n\r\n    public static setCurrentContext(newContext: ISparkySelf) {\r\n        this.__context = newContext;\r\n    }\r\n\r\n    public static resetIndexes() {\r\n        if(!this.__context) throw new ReferenceError(\"Try to reset index on a undefined context\");\r\n        this.__context.indexes.memo = 0;\r\n        this.__context.indexes.update = 0;\r\n        this.__context.indexes.state = 0;\r\n    }\r\n\r\n    public static newContext(newContext: ISparkySelf) : ISparkySelf {\r\n        return cloneDeep({...this.__defaultContext, ...newContext, __id: nanoid(12)});\r\n    }\r\n}","import { arrayAreSame } from \"./sparky.helper\";\r\nimport { IFnCached, IArgumentsList } from \"./sparky.function\";\r\nimport { ISparkySelf } from \"./sparky.context\";\r\n\r\ntype ICachedType = \"memoize\" | \"update\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function callCachedFn(context: ISparkySelf, type: ICachedType, cachedArray: IFnCached[], callbackFn: Function, argumentsChanged?: IArgumentsList) {\r\n    const fnCached = cachedArray[getIndexByType(context, type)];\r\n    incrementIndexByType(context, type)\r\n\r\n    const newMemo = {\r\n        fn: callbackFn,\r\n        result: null,\r\n        dependencies: argumentsChanged\r\n    };\r\n\r\n    if (!fnCached || !argumentsChanged) {\r\n        newMemo.result = callbackFn.call(window, argumentsChanged ? [...argumentsChanged] : null);\r\n        cachedArray.push(newMemo)\r\n        return newMemo.result;\r\n    }\r\n\r\n    if (!arrayAreSame(fnCached.dependencies, argumentsChanged)) {\r\n        fnCached.dependencies = argumentsChanged;\r\n        fnCached.result = callbackFn.call(window, ...argumentsChanged);\r\n        return fnCached.result;\r\n    }\r\n\r\n    return fnCached.result;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction getIndexByType(context: ISparkySelf, type: ICachedType) {\r\n    if (type == \"memoize\")\r\n        return context.indexes.memo;\r\n    return context.indexes.update;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction incrementIndexByType(context: ISparkySelf, type: ICachedType) {\r\n    if (type == \"memoize\")\r\n        return ++context.indexes.memo;\r\n    return ++context.indexes.update;\r\n}","/**\r\n * @internal\r\n */\r\ninterface ISortArray {\r\n    bigArray: any[];\r\n    smallArray: any[];\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function arrayAreSame(array1: any[], array2: any[]) {\r\n    const { bigArray, smallArray } = sortArrayInObject(array1, array2);\r\n\r\n    return bigArray.every((big, i) => {\r\n        return big == (smallArray ? smallArray[i] : null);\r\n    })\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction sortArrayInObject(array1: any[], array2: any[]): ISortArray {\r\n    const length_1 = array1.length;\r\n    const length_2 = array2.length;\r\n\r\n    if(length_1 > length_2) return { bigArray: array1, smallArray: array2 }\r\n\r\n    return { bigArray: array2, smallArray: array1 }\r\n}","import { IStateRoute, Sparky } from \"./sparky\"\r\nimport { HTMLElementSparkyEnhanced, ISparkyRoot, IParams } from \"./sparky.component\";\r\n/**\r\n * @internal\r\n */\r\ndeclare var thisTest;\r\nexport type IRoutingTypes = \"browser\" | \"hash\" | \"abstract\";\r\n/**\r\n * @internal\r\n */\r\nexport interface documentSparkyEnhanced extends Document {\r\n    __sparkyRoutingId: string;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function listeningHashChange(stateRoute: IStateRoute[], callbackFn: Function, dom: HTMLElementSparkyEnhanced) {\r\n    if(!dom.__sparkyRoot.isRoutingEnabled)\r\n        throw TypeError(\"To use route() function, you need to pass a Sparky.router object on the mount function\");\r\n    window.requestIdleCallback(() => {\r\n        window.addEventListener(\"hashchange\", (evt) => {\r\n            changeStateByEvent(evt, stateRoute, callbackFn, dom)\r\n        })\r\n    })\r\n    if(typeof thisTest != \"undefined\" && thisTest.testing) {\r\n        const evt = new Event(\"hashchange\") as HashChangeEvent;\r\n        Object.defineProperty(evt, 'oldUrl', {writable: false, value: \"\"});\r\n        Object.defineProperty(evt, 'newURL', {writable: true, value: \"#\"});\r\n        changeStateByEvent(evt, stateRoute, callbackFn, dom);\r\n        dom.__sparkyRoot.stateChanging = true;\r\n        dom.__sparkyRoot.basename = dom.__sparkyRoot.basename ? dom.__sparkyRoot.basename : \"\"; \r\n        dom.__sparkyRoot.forceURLUpdate = true;\r\n        changeStateByEvent(evt, stateRoute, callbackFn, dom)\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction changeStateByEvent(evt: HashChangeEvent, stateRoute: IStateRoute[], callbackFn: Function, dom: HTMLElementSparkyEnhanced) {\r\n    const documentSparky = document as documentSparkyEnhanced;\r\n\r\n    if(dom.__sparkyRoot.forceURLUpdate) \r\n        documentSparky.__sparkyRoutingId = dom.__sparkyRoot.id;\r\n\r\n    if(documentSparky.__sparkyRoutingId \r\n        && documentSparky.__sparkyRoutingId != dom.__sparkyRoot.id) {\r\n            console.warn(\"Only one route object can have the control of URL\")\r\n            return;\r\n        }\r\n    if(evt.oldURL == evt.newURL || dom.__sparkyRoot.stateChanging) {\r\n        dom.__sparkyRoot.stateChanging = false;\r\n        return;\r\n    };\r\n    const newState = getStateByHash(stateRoute, location.hash);\r\n    newState.hash = location.hash;\r\n    dom.__sparkyRoot.params = getParamsByPath(newState.path, location.hash);\r\n    pushToAbstractHistory(dom.__sparkyRoot, newState);\r\n    if(newState) {\r\n        callbackFn(newState.component);\r\n    }\r\n    documentSparky.__sparkyRoutingId = dom.__sparkyRoot.id;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function getStateByHash(stateRoute: IStateRoute[], newPath: string) {\r\n    return stateRoute.find((state, i) => {\r\n        if (typeof state.path == \"string\") {\r\n            state.exact = true;\r\n            return matchUrl(state.path, newPath);\r\n        }\r\n        return false;\r\n    }) || {...stateRoute[0], exact: false};\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function pushToAbstractHistory(sparkyRoot: ISparkyRoot, stateRoute: IStateRoute) {\r\n    if(sparkyRoot.historyIndex < (history.length - 1)) {\r\n        sparkyRoot.history = sparkyRoot.history.slice(0, sparkyRoot.historyIndex + 1)\r\n    }\r\n    sparkyRoot.history.push(stateRoute);\r\n    sparkyRoot.historyIndex = sparkyRoot.history.length - 1;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function Sparky_cleanHistory(this: HTMLElementSparkyEnhanced) {\r\n    this.__sparkyRoot.history = [];\r\n    this.__sparkyRoot.historyIndex = 0;\r\n    this.__sparkyRoot.stateChanging = true;\r\n    location.hash = \"\";\r\n} \r\n\r\n/**\r\n * @internal\r\n */\r\nexport function Sparky__goToState(this: HTMLElementSparkyEnhanced, newPath: string) {\r\n    let { routing, type, basename } = this.__sparkyRoot;\r\n    const routeState = getStateByHash(routing, newPath);\r\n    routeState.hash = newPath;\r\n    if(routeState.exact)\r\n        this.__sparkyRoot.params = getParamsByPath(routeState.path, newPath);\r\n    this.__sparkyRoot.stateChanging = true;\r\n    let normalizePath = newPath;\r\n    switch(type) {\r\n        case \"hash\": location.hash = \"/\" + normalizePath; break;\r\n        case \"browser\": location.pathname = basename + \"/\" + normalizePath; break;\r\n    }\r\n    pushToAbstractHistory(this.__sparkyRoot, routeState);\r\n    Sparky.mount(routeState.component, this);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function Sparky__back(this: HTMLElementSparkyEnhanced) {\r\n    let { history, type, basename } = this.__sparkyRoot;\r\n    if (this.__sparkyRoot.historyIndex - 1 < 0) return;\r\n    const state = history[--this.__sparkyRoot.historyIndex];\r\n    if(state.exact)\r\n        this.__sparkyRoot.params = getParamsByPath(state.path, state.hash);\r\n    this.__sparkyRoot.stateChanging = true;\r\n    let normalizePath = state.hash;\r\n    switch(type) {\r\n        case \"hash\": location.hash = \"/\" + normalizePath; break;\r\n        case \"browser\": location.pathname = basename + \"/\" + normalizePath; break;\r\n    }\r\n    Sparky.mount(state.component, this);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function Sparky__forward(this: HTMLElementSparkyEnhanced) {\r\n    let { history, type, basename } = this.__sparkyRoot;\r\n    if (this.__sparkyRoot.historyIndex + 1 > history.length - 1) return; \r\n    const state = history[++this.__sparkyRoot.historyIndex];\r\n    if(state.exact)\r\n        this.__sparkyRoot.params = getParamsByPath(state.path, state.hash);\r\n    this.__sparkyRoot.stateChanging = true;\r\n    let normalizePath = state.hash;\r\n    switch(type) {\r\n        case \"hash\": location.hash = \"/\" + normalizePath; break;\r\n        case \"browser\": location.pathname = basename + \"/\" + normalizePath; break;\r\n    }\r\n    Sparky.mount(state.component, this)\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function Sparky__params(this: HTMLElementSparkyEnhanced) {\r\n    const { params } = this.__sparkyRoot;\r\n    return params;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function Sparky__currentState(this: HTMLElementSparkyEnhanced) {\r\n    const { history, historyIndex } = this.__sparkyRoot;\r\n    return history[historyIndex];\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function getParamsByPath(path:string, url: string): IParams[] {\r\n    if(path.includes(\"*\")) {  \r\n        const pathArray = path.split(\"*\");  \r\n        if(pathArray[1].includes(\"/\")) \r\n            throw TypeError(\"The wildcard can only be the last element to be identified on the url\");        \r\n    }\r\n    const urlParts = url.split(\"/\");\r\n    const params = [];\r\n    path.split(\"/\").reduce((params, pathPart, i) =>  {\r\n        if(pathPart.startsWith(\":\")) {\r\n            const obj = {};\r\n            obj[pathPart.slice(1, pathPart.length)] = urlParts[i];\r\n            params.push(obj as IParams);\r\n        } else if(pathPart.startsWith(\"*\")) {\r\n            const obj = {};\r\n            obj[pathPart.slice(1, pathPart.length)] = urlParts.slice(i, urlParts.length).join(\"\");\r\n            params.push(obj as IParams)\r\n        }\r\n        return params;\r\n    }, params);\r\n\r\n    return params;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function matchUrl(path:string, url: string) {\r\n    if(path.includes(\"*\")) {\r\n        const pathArray = path.split(\"*\");\r\n        if(pathArray[1].includes(\"/\")) \r\n            throw TypeError(\"The wildcard can only be the last element to be identified on the url\");        \r\n    }\r\n    const pathPart = path.split(\"/\").filter((part) => {\r\n        return !part.startsWith(\":\") && !part.startsWith(\"*\")\r\n    })\r\n\r\n    return url.includes(pathPart.join(\"/\"))\r\n}","window.requestIdleCallback =\n    window.requestIdleCallback ||\n    function(cb) {\n        var start = Date.now();\n        return setTimeout(function() {\n            cb({\n                didTimeout: false,\n                timeRemaining: function() {\n                    return Math.max(0, 50 - (Date.now() - start));\n                },\n            });\n        }, 1);\n    };\n\nwindow.cancelIdleCallback =\n    window.cancelIdleCallback ||\n    function(id) {\n        clearTimeout(id);\n    };\n","import { Sparky, ISparkyStore } from \"./sparky\";\r\nimport 'requestidlecallback-polyfill';\r\nimport { callCachedFn } from \"./sparky.function.helper\";\r\nimport { SparkyContext, ISparkySelf } from \"./sparky.context\";\r\nimport { Sparky__goToState, Sparky__back, Sparky__forward, Sparky_cleanHistory, Sparky__params, Sparky__currentState } from \"./sparky.router\";\r\nimport { IParams } from \"./sparky.component\";\r\n\r\nexport type ISetStateOrDispatcher<S> = (newStateOrAction: S | IDispatcherAction | INewStateFunction<S>) => void;\r\nexport type IArgumentsList = any[];\r\nexport type IDispatcherAction = { [x: string]: string | number | boolean | null | undefined};\r\ntype IUpdateCallback = () => void;\r\ntype INewStateFunction<S> = (prevState: S) => S;\r\ntype IBoundSetCurrentState = {\r\n    context: ISparkySelf;\r\n    state: number;\r\n    rootElement: HTMLElement;\r\n};\r\n\r\nexport interface IRouterFunctions {\r\n    /**\r\n     * Convenience method for transitioning to a new state.\r\n     * @params newPath to transitioning to that new state\r\n     */\r\n    goToState: (newPath: string) => void, \r\n    /**\r\n     * Convenience method for transitioning go back on history\r\n     */\r\n    goBack: () => void, \r\n    /**\r\n     * Convenience method for transitioning go forward on history\r\n     */\r\n    goAfter: () => void, \r\n    /**\r\n     * Returns an object of key/value pairs of parameters matched on the url\r\n     */\r\n    getParams: () => IParams[], \r\n    /**\r\n     * Convenience method to clean History stack\r\n     */\r\n    cleanHistory: () => void,\r\n    /**\r\n     * Get current state of the router\r\n     */\r\n    getCurrentState: () => void\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface IFnCached {\r\n    fn: Function;\r\n    dependencies: string[];\r\n    result: any;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nconst getContext = () => {\r\n    const currentContext = SparkyContext.getCurrentContext();\r\n    if (!currentContext)\r\n        throw new ReferenceError(\"Sparky Function only can be used in the lifecycle of a Sparky application\");\r\n    return currentContext;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nconst setContext = (newContext: ISparkySelf) => {\r\n    SparkyContext.setCurrentContext(newContext);\r\n    SparkyContext.resetIndexes();\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nconst setCurrentState = function <S>(this: IBoundSetCurrentState, newState: S | ((prevState: S) => S) ) {\r\n    setContext(this.context);\r\n    const currentContext = getContext();\r\n    currentContext.indexes.state = this.state;\r\n    const prevState = currentContext.cachedState[currentContext.indexes.state];\r\n    currentContext.cachedState[currentContext.indexes.state] = \r\n        typeof(newState) == \"function\" ? (newState as INewStateFunction<S>)(prevState) : newState;\r\n    currentContext.indexes.state++;\r\n    if (currentContext.__root) {\r\n        SparkyContext.setCurrentContext(Sparky.mount({ \r\n            ...currentContext.__root, currentContext }, currentContext.__rootElement));\r\n    } else {\r\n        SparkyContext.setCurrentContext(\r\n            Sparky.mount({ type: \"SparkyComponent\", \r\n            context: currentContext, currentContext, renderFn: currentContext.renderFunc }, currentContext.__rootElement));\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nconst setInitialState = <S>(newState: S): ISetStateOrDispatcher<S> => {\r\n    const currentContext = getContext();\r\n    currentContext.cachedState[currentContext.indexes.state] = newState;\r\n    return setCurrentState;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const Sparky__update = (callbackFn: IUpdateCallback, dependenciesChanged?: IArgumentsList) => {\r\n    const currentContext = getContext();\r\n    window.requestIdleCallback(() => {\r\n        callCachedFn(currentContext, \"update\", currentContext.cachedUpdate, callbackFn, dependenciesChanged)\r\n    }, { timeout: 250 });\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const Sparky__state = <S>(initialState: S | ISparkyStore<S>): [S, ISetStateOrDispatcher<S>] => {\r\n    if(typeof(initialState) == \"object\") {\r\n        const initialStore = initialState as ISparkyStore<S>;\r\n        if(initialStore.type && initialStore.type == \"SparkyStore\") {\r\n            return Sparky__store(initialStore);\r\n        }\r\n    }\r\n    const currentContext = getContext();\r\n    const bound = { context: currentContext, state: currentContext.indexes.state }\r\n    const currentState = currentContext.cachedState[currentContext.indexes.state];\r\n    if(currentState) {\r\n        currentContext.indexes.state++;\r\n        const setState = setCurrentState;\r\n        return [currentState as S, setState.bind(bound)];\r\n    }\r\n    const setState = setInitialState(initialState);\r\n    currentContext.indexes.state++;\r\n    const lastIndex = currentContext.indexes.state - 1;\r\n    return [currentContext.cachedState[lastIndex] as S, setState.bind(bound)];\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const Sparky__memoize = (callbackFn: Function, argumentsChanged?: IArgumentsList) => {\r\n    const currentContext = getContext();\r\n    callCachedFn(currentContext, \"memoize\", currentContext.cachedMemo, callbackFn, argumentsChanged)\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const Sparky__internal_history = () : IRouterFunctions => {\r\n    const currentContext = getContext();\r\n    if(!currentContext.__rootElement.__sparkyRoot.isRoutingEnabled)\r\n        throw TypeError(\"To use router() function, you need to pass a Sparky.router object on the mount function\");\r\n    const goToState = Sparky__goToState.bind(currentContext.__rootElement);\r\n    const goBack = Sparky__back.bind(currentContext.__rootElement);\r\n    const goAfter = Sparky__forward.bind(currentContext.__rootElement);\r\n    const getParams = Sparky__params.bind(currentContext.__rootElement);\r\n    const cleanHistory = Sparky_cleanHistory.bind(currentContext.__rootElement);\r\n    const getCurrentState = Sparky__currentState.bind(currentContext.__rootElement);\r\n\r\n    return { goToState, goBack, goAfter, getParams, cleanHistory, getCurrentState };\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const Sparky__store = <T>(store: ISparkyStore<T>): [T, (action: IDispatcherAction) => void] => {\r\n    return [store.store, (action: IDispatcherAction) => store.dispatcher(store, action)];\r\n}","import nanoid from \"nanoid/non-secure\";\r\n\r\nimport 'mdn-polyfills/Array.from';\r\nimport 'mdn-polyfills/Array.prototype.find';\r\n\r\nimport { reconciliate } from \"./sparky.dom\";\r\nimport { EventManager } from \"./sparky.eventmanager\";\r\nimport { SparkyComponent, HTMLElementSparkyEnhanced, IParams } from \"./sparky.component\";\r\nimport { SparkyContext, ISparkySelf } from \"./sparky.context\";\r\n\r\nimport cloneDeep from \"clone-deep\";\r\n\r\nimport { isConnectedPolyfill } from \"./polyfill/isConnected\";\r\nimport { Sparky__state, Sparky__update, Sparky__memoize, Sparky__internal_history, Sparky__store, IDispatcherAction } from \"./sparky.function\";\r\nimport { listeningHashChange, getStateByHash, getParamsByPath } from \"./sparky.router\";\r\n\r\nisConnectedPolyfill();\r\n\r\n/**\r\n * @internal\r\n */\r\ndeclare var thisTest;\r\n/**\r\n * @internal\r\n */\r\ndeclare var thisTestEvent;\r\n\r\nexport interface IRenderReturn {\r\n    type: string;\r\n    html: string;\r\n    func: ISparkyEventFunc[],\r\n    nestedComponents: ISparkyComponent[];\r\n    children: IRenderReturn[];\r\n    renderId: string;\r\n}\r\n\r\nexport interface IStateRoute {\r\n    hash?: string;\r\n    exact?: boolean;\r\n    path: string;\r\n    component: ISparkyComponent;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface IReconciliateProps {\r\n    dom: HTMLElement,\r\n    func: ISparkyEventFunc[],\r\n}\r\n\r\nexport type ISparkyFunction = (props?: any) => IRenderReturn;\r\n\r\nexport interface ISparkyEventFunc {\r\n    renderId: string;\r\n    index: number;\r\n    func: Function;\r\n}\r\n\r\nexport interface ISparkyComponent {\r\n    type: string;\r\n    context: ISparkySelf;\r\n    currentContext: ISparkySelf;\r\n    renderFn: ISparkyFunction;\r\n}\r\n\r\nexport interface ISparkyRouterOptions {\r\n    type?: \"hash\" | \"abstract\" | \"browser\";\r\n    basename?: string;\r\n    forceUrlUpdate?: boolean;\r\n}\r\n\r\nexport interface ISparkyRouter {\r\n    type: string;\r\n    component: ISparkyComponent;\r\n    routing: IStateRoute[];\r\n    history: IStateRoute[];\r\n    params: IParams[];\r\n    options: ISparkyRouterOptions;\r\n}\r\n\r\nexport type ISparkyStore<T> = {store: T, dispatcher : (store: ISparkyStore<T>, action: IDispatcherAction) => void, type: string}\r\n\r\nexport interface ISparkyProps {\r\n    [key: string]: any;\r\n}\r\n\r\nexport type ISparkyState = ISparkyProps;\r\n\r\nexport class Sparky {\r\n\r\n    /**\r\n     * Generate a Sparky Component that can be mount.\r\n     * @param renderFunc The function that going to be execute to render html template\r\n     */\r\n    static component(renderFunc: ISparkyFunction, props?: ISparkyProps) {\r\n        const sparkyContext = SparkyContext.newContext({ props, renderFunc });\r\n        return { type: \"SparkyComponent\", context: sparkyContext, currentContext: sparkyContext, renderFn: renderFunc } as ISparkyComponent;\r\n    }\r\n\r\n    /**\r\n     * Create a routing component that manage history\r\n     * @param stateRoute \r\n     */\r\n    static router(stateRoute: IStateRoute[], options?: ISparkyRouterOptions): ISparkyRouter {\r\n        if(!options) options = { type: \"hash\" };\r\n        let locationString = \"\";\r\n        if(options.type == \"hash\") {\r\n            locationString = location.hash.slice(2, location.hash.length);\r\n        } else if (options.type == \"browser\") {\r\n            locationString = location.pathname;\r\n        }\r\n        const routeState = getStateByHash(stateRoute, locationString);\r\n        routeState.hash = locationString;\r\n        let params = []\r\n        if(routeState.exact)\r\n            params = getParamsByPath(routeState.path, locationString);\r\n        return { type: \"SparkyRouter\", component: routeState.component, routing: stateRoute, history: [routeState], params, options };\r\n    }\r\n\r\n    /**\r\n     * Mount a Sparky Component in the DOM Tree and keep it updated.\r\n     * @param component Sparky Component\r\n     * @param dom The dom element where you want to mount this component\r\n     */\r\n    static mount(element: ISparkyComponent | ISparkyRouter, dom: HTMLElementSparkyEnhanced): ISparkySelf {\r\n        if (process.env.NODE_ENV === 'development')\r\n            console.time();\r\n        \r\n        const component = ((element.type == \"SparkyComponent\") ? element : (element as ISparkyRouter).component) as ISparkyComponent \r\n\r\n        initialiseDOM(dom, element);\r\n\r\n        const { context, renderFn } = component;\r\n\r\n        const keepIndexes = cloneDeep(component.currentContext.indexes);\r\n\r\n        context.__rootElement = dom; \r\n        SparkyContext.setCurrentContext(context);\r\n        SparkyContext.resetIndexes();\r\n\r\n        const render = renderFn(Object.freeze(context.props)) as IRenderReturn;\r\n\r\n        const oldDom = dom.__sparkyRoot.updateAt ? (dom.firstElementChild as HTMLElementSparkyEnhanced) : null;\r\n        let nextDOM = renderToDOMNode(render.html);\r\n\r\n        nextDOM = SparkyComponent.populate(nextDOM, render, component);\r\n\r\n\r\n        let finalDOM = reconciliate(oldDom, nextDOM);\r\n        if (!finalDOM) return;\r\n        if (!finalDOM.isConnected && dom)\r\n            dom.appendChild(finalDOM);\r\n\r\n        dom.__sparkyRoot.updateAt = new Date().getTime();\r\n\r\n        EventManager.listen(finalDOM);\r\n\r\n        if (process.env.NODE_ENV === 'development')\r\n            console.timeEnd();\r\n\r\n        if(typeof thisTest != \"undefined\" && thisTest.testing) {\r\n            thisTest.__testUtilData = {\r\n                root: dom,\r\n                component,\r\n                eventList: thisTestEvent\r\n            };\r\n        }\r\n        \r\n        return {...component.currentContext, indexes: keepIndexes};\r\n    }\r\n\r\n    /**\r\n     * Create a Store to using it on components\r\n     * @param newStore Object that will be Store\r\n     * @param dispatcher Function that will run for changing programatically store object\r\n     */\r\n    static createStore<S>(newStore: S, dispatcher: (state: S, action: IDispatcherAction) => S): ISparkyStore<S> {\r\n        return {\r\n            type: \"SparkyStore\",\r\n            store: newStore,\r\n            dispatcher: (store, action) => { store.store = dispatcher(store.store, action) }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Reconciliate the current DOM with the new DOM Node\r\n     * @internal\r\n     * @param oldNode Node that need to be reconcile\r\n     * @param newNode Node that have the new elements\r\n     */\r\n    static reconciliate(oldNode: HTMLElement, newNode: HTMLElement) {\r\n        return reconciliate(oldNode, newNode)\r\n    }\r\n}\r\n\r\n/**\r\n * Function will be run after the render is commited to the screen.\r\n * @param callbackFn - The function to run\r\n * @param dependenciesChanged - Array of values that the function depends on\r\n */\r\nexport const update = Sparky__update;\r\n\r\n/**\r\n * Returns a stateful value, and a function to update it.\r\n * @param initialState The value during the first render\r\n */\r\nexport const state = Sparky__state;\r\n\r\n/**\r\n * Run and returns a memoized value\r\n * @param callbackFn - Function will be run on rendering phase\r\n * @param argumentsChanged - Array of values that the function depends on\r\n */\r\nexport const memoize = Sparky__memoize;\r\n\r\n/**\r\n * Returns routing functions for current mounted component\r\n */\r\nexport const router = Sparky__internal_history;\r\n\r\n/**\r\n * Render the html string template to HTML elements\r\n * @param html Array of HTML String \r\n * @param computedProps Computed Props used to pass Javascript into template\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals\r\n */\r\nexport function html(html: TemplateStringsArray | string, ...computedProps: any[]): IRenderReturn {\r\n    const func: ISparkyEventFunc[] = [];\r\n    const nestedComponents: ISparkyComponent[] = [];\r\n    const children: IRenderReturn[] = [];\r\n    const renderId = nanoid(12);\r\n\r\n    const newHTML = (typeof html == \"string\") ? html\r\n        : html.map((stringHTML, i) => {\r\n            let htmlLine = \"\"\r\n            htmlLine += stringHTML\r\n            if (!computedProps[i]) return htmlLine;\r\n            htmlLine = getComputedValue(computedProps, i, func, htmlLine, nestedComponents, children, renderId);\r\n            return htmlLine;\r\n        })\r\n\r\n    const innerHTML = Array.isArray(newHTML) ? newHTML.join(\"\") : newHTML;\r\n\r\n    return { type: \"SparkyRender\", html: innerHTML, func, nestedComponents, children, renderId };\r\n}\r\n\r\n/**\r\n * @internal\r\n * @param computedProps \r\n * @param i \r\n * @param func \r\n * @param htmlLine \r\n * @param nestedComponents \r\n * @param children \r\n * @param renderId \r\n */\r\nfunction getComputedValue(computedProps: any[], i: number, func: ISparkyEventFunc[], htmlLine: string, nestedComponents: ISparkyComponent[], children: IRenderReturn[], renderId: string) {\r\n    if (typeof computedProps[i] == \"function\") {\r\n        func.push({ index: func.length - 1, renderId, func: computedProps[i] });\r\n        htmlLine += `'SparkyFunction#${renderId}#${func.length - 1}'`;\r\n    }\r\n    else if (computedProps[i].type == \"SparkyRender\") {\r\n        const render = computedProps[i] as IRenderReturn;\r\n        htmlLine += render.html;\r\n        children.push(render)\r\n    }\r\n    else if (computedProps[i].type == \"SparkyComponent\") {\r\n        const comp = computedProps[i] as ISparkyComponent;\r\n        htmlLine += `<!-- SparkyComponent#${comp.renderFn.name}#${nestedComponents.length}#${renderId} -->`;\r\n        nestedComponents.push(comp);\r\n    }\r\n    else {\r\n\r\n        computedProps[i] = Array.isArray(computedProps[i]) ?\r\n            computedProps[i].join(\"\") : new String(computedProps[i]);\r\n        if ((computedProps[i] as string).startsWith(\"<\"))\r\n            htmlLine += computedProps[i];\r\n        else\r\n            htmlLine += `<span class='computed'>${computedProps[i]}</span>`;\r\n    }\r\n    return htmlLine;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @param dom \r\n * @param element \r\n */\r\nfunction initialiseDOM(dom: HTMLElementSparkyEnhanced, element: ISparkyComponent | ISparkyRouter) {\r\n    if (dom && !dom.__sparkyRoot) {\r\n        setRootProperties(dom);\r\n        if (element.type == \"SparkyRouter\") {\r\n            const { history, routing, params, options } = element as ISparkyRouter;\r\n            dom.__sparkyRoot = { ...dom.__sparkyRoot, history, \r\n                routing, params, \r\n                basename: options?.basename, \r\n                isRoutingEnabled: true,\r\n                forceURLUpdate: options?.forceUrlUpdate,\r\n                type: options?.type\r\n            };\r\n            if(dom.__sparkyRoot.type == \"hash\") {\r\n                listeningHashChange(routing, (component) => {\r\n                    Sparky.mount(component, dom);\r\n                }, dom);                \r\n            }\r\n        }\r\n    }\r\n    ;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @param dom \r\n */\r\nfunction setRootProperties(dom: HTMLElementSparkyEnhanced) {\r\n    dom.__sparkyRoot = { \r\n        id: nanoid(12),\r\n        isRoutingEnabled: false,\r\n        basename: \"\",\r\n        params: [],\r\n        forceURLUpdate: false,\r\n        type: \"hash\",\r\n        historyIndex: 0,\r\n        stateChanging: false,\r\n        history: [],\r\n        routing: [],\r\n        updateAt: null\r\n    };\r\n}\r\n\r\n/**\r\n * @internal\r\n * @param html \r\n */\r\nexport function renderToDOMNode(html: string) {\r\n    const div = document.createElement(\"div\");\r\n    div.innerHTML = html;\r\n    if (div.children.length > 1) {\r\n        throw new TypeError(\"Adjacent elements on the root level are forbidden.\");\r\n    }\r\n    return div.firstElementChild as HTMLElement;\r\n}","String.prototype.startsWith||(String.prototype.startsWith=function(t,r){return r=r||0,this.substr(r,t.length)===t});\n","import { IRenderReturn, ISparkyComponent, renderToDOMNode, IStateRoute } from \"./sparky\";\r\nimport { findEvent } from \"./sparky.event\";\r\nimport { eventCallbackFn, IEventSingle } from \"./sparky.eventmanager\";\r\nimport { SparkyContext } from \"./sparky.context\";\r\nimport { IRoutingTypes } from \"./sparky.router\";\r\n\r\nexport interface IParams {\r\n    [x: string]: string\r\n}\r\nexport interface ISparkyRoot {\r\n    id: string;\r\n    isRoutingEnabled: boolean;\r\n    type: IRoutingTypes;\r\n    basename: string;\r\n    forceURLUpdate: boolean;\r\n    historyIndex: number;\r\n    stateChanging: boolean;\r\n    params: IParams[];\r\n    history: IStateRoute[];\r\n    routing: IStateRoute[];\r\n    updateAt: number;\r\n}\r\n\r\nexport interface HTMLElementSparkyEnhanced extends HTMLElement {\r\n    __sparkyEvent?: IEventSingle;\r\n    __sparkyRoot?: ISparkyRoot;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\ninterface ICachedComponent {\r\n    component: ISparkyComponent,\r\n    dom: HTMLElement\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class SparkyComponent {\r\n    private static cachedComponent: ICachedComponent[][] = [];\r\n    static populate(nextDOM: HTMLElement, render: IRenderReturn, rootComponent: ISparkyComponent) {\r\n        \r\n        const renderQueue: [IRenderReturn, ISparkyComponent, HTMLElement][] = [[render, rootComponent, nextDOM]];\r\n\r\n        let depthHorizontal = 0;\r\n\r\n        while (renderQueue.length > 0) {\r\n            const [currentRender, currentComponent, currentDOM] = renderQueue.shift();\r\n            if(!this.cachedComponent[depthHorizontal]) this.cachedComponent[depthHorizontal] = [];\r\n\r\n            currentRender.func.forEach((currentFunc, index) => {\r\n                const currentEvent = findEvent(currentDOM, currentRender.renderId, index);\r\n                const eventName = currentEvent.attr.name.replace(\"on\", \"\");\r\n                currentEvent.dom.__sparkyEvent = {\r\n                    type: eventName,\r\n                    context: currentComponent.context,\r\n                    callbackFn: currentFunc.func as eventCallbackFn\r\n                };\r\n                currentEvent.dom.removeAttribute(currentEvent.attr.name)\r\n            })\r\n\r\n            currentRender.children.forEach((currentChild) => {\r\n                renderQueue.push([currentChild, currentComponent, currentDOM])\r\n            })\r\n\r\n            currentRender.nestedComponents.forEach((currentComp, index) => {\r\n                const cached = this.cachedComponent[depthHorizontal][index];\r\n                const commentDom = this.findComment(currentDOM, currentRender.renderId, index, currentComp.renderFn.name);\r\n                if(cached) {\r\n                    if(cached.component.renderFn.name == \"\") {\r\n                        if(cached.component.renderFn.toString() == currentComp.renderFn.toString()) {\r\n                            currentComp = getCachedComponent(cached, currentComp);\r\n                        }\r\n                    } else if(cached.component.renderFn.name == currentComp.renderFn.name){\r\n                        currentComp = getCachedComponent(cached, currentComp);\r\n                    }\r\n                }\r\n                SparkyContext.setCurrentContext(currentComp.context);\r\n                SparkyContext.resetIndexes();\r\n                currentComp.context.__root = rootComponent;\r\n                currentComp.context.__rootElement = rootComponent.context.__rootElement;\r\n                const renderChild = currentComp.renderFn(Object.freeze(currentComp.context.props));\r\n                if(!commentDom) return;\r\n                const renderChildDOM = renderToDOMNode(renderChild.html);\r\n                commentDom.parentNode.replaceChild(renderChildDOM, commentDom);\r\n                render.func.push(...renderChild.func);\r\n                renderQueue.push([renderChild, currentComp, renderChildDOM]);\r\n\r\n                this.cachedComponent[depthHorizontal][index] = {\r\n                    component: currentComp,\r\n                    dom: currentDOM\r\n                };\r\n            });\r\n            if(currentRender.nestedComponents.length > 0)\r\n                depthHorizontal++;\r\n        }\r\n        \r\n        return nextDOM;\r\n    }\r\n\r\n    private static findComment(element: HTMLElement, renderId: string, i: number, componentName: string) {\r\n        const domQueue = [element];\r\n        while(domQueue.length > 0) {\r\n            const elem = domQueue.shift();\r\n            if(elem.nodeName == '#comment' && elem.nodeValue.trim() == `SparkyComponent#${componentName}#${i}#${renderId}`) {\r\n                return elem;\r\n            }\r\n\r\n            for(let i = 0; i < elem.childNodes.length; i++) {\r\n                domQueue.push(elem.childNodes[i] as HTMLElement);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction getCachedComponent(cached: ICachedComponent, currentComp: ISparkyComponent) {\r\n    cached.component.context.props = currentComp.context.props;\r\n    currentComp = cached.component;\r\n    return currentComp;\r\n}\r\n","import 'mdn-polyfills/String.prototype.startsWith';\r\nimport { HTMLElementSparkyEnhanced } from './sparky.component';\r\n\r\n/**\r\n * @internal\r\n */\r\ninterface IEventReturn {\r\n    dom: HTMLElementSparkyEnhanced;\r\n    attr: Attr;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function findEvent(element: HTMLElement, renderId: string, index: number) : IEventReturn {\r\n    const domQueue = [element];\r\n    while(domQueue.length > 0) {\r\n        const elem = domQueue.shift();\r\n        const eventAttr = Array.from(elem.attributes).find((attr) => {\r\n            if(attr.name.startsWith(\"on\")) {\r\n                return attr.value == `SparkyFunction#${renderId}#${index}`;\r\n            }\r\n        })\r\n\r\n        if(eventAttr) return {dom: elem, attr: eventAttr};\r\n\r\n        for(let index = 0; index < elem.children.length; index++) {\r\n            domQueue.push(elem.children[index] as HTMLElement)\r\n        }\r\n    }\r\n}","import nanoid from \"nanoid/non-secure\";\r\n\r\nimport 'mdn-polyfills/Array.from';\r\nimport 'mdn-polyfills/Array.prototype.find';\r\n\r\nimport { reconciliate } from \"./sparky.dom\";\r\nimport { EventManager } from \"./sparky.eventmanager\";\r\nimport { SparkyComponent, HTMLElementSparkyEnhanced, IParams } from \"./sparky.component\";\r\nimport { SparkyContext, ISparkySelf } from \"./sparky.context\";\r\n\r\nimport cloneDeep from \"clone-deep\";\r\n\r\nimport { isConnectedPolyfill } from \"./polyfill/isConnected\";\r\nimport { Sparky__state, Sparky__update, Sparky__memoize, Sparky__internal_history, Sparky__store, IDispatcherAction } from \"./sparky.function\";\r\nimport { listeningHashChange, getStateByHash, getParamsByPath } from \"./sparky.router\";\r\n\r\nisConnectedPolyfill();\r\n\r\n/**\r\n * @internal\r\n */\r\ndeclare var thisTest;\r\n/**\r\n * @internal\r\n */\r\ndeclare var thisTestEvent;\r\n\r\nexport interface IRenderReturn {\r\n    type: string;\r\n    html: string;\r\n    func: ISparkyEventFunc[],\r\n    nestedComponents: ISparkyComponent[];\r\n    children: IRenderReturn[];\r\n    renderId: string;\r\n}\r\n\r\nexport interface IStateRoute {\r\n    hash?: string;\r\n    exact?: boolean;\r\n    path: string;\r\n    component: ISparkyComponent;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface IReconciliateProps {\r\n    dom: HTMLElement,\r\n    func: ISparkyEventFunc[],\r\n}\r\n\r\nexport type ISparkyFunction = (props?: any) => IRenderReturn;\r\n\r\nexport interface ISparkyEventFunc {\r\n    renderId: string;\r\n    index: number;\r\n    func: Function;\r\n}\r\n\r\nexport interface ISparkyComponent {\r\n    type: string;\r\n    context: ISparkySelf;\r\n    currentContext: ISparkySelf;\r\n    renderFn: ISparkyFunction;\r\n}\r\n\r\nexport interface ISparkyRouterOptions {\r\n    type?: \"hash\" | \"abstract\" | \"browser\";\r\n    basename?: string;\r\n    forceUrlUpdate?: boolean;\r\n}\r\n\r\nexport interface ISparkyRouter {\r\n    type: string;\r\n    component: ISparkyComponent;\r\n    routing: IStateRoute[];\r\n    history: IStateRoute[];\r\n    params: IParams[];\r\n    options: ISparkyRouterOptions;\r\n}\r\n\r\nexport type ISparkyStore<T> = {store: T, dispatcher : (store: ISparkyStore<T>, action: IDispatcherAction) => void, type: string}\r\n\r\nexport interface ISparkyProps {\r\n    [key: string]: any;\r\n}\r\n\r\nexport type ISparkyState = ISparkyProps;\r\n\r\nexport class Sparky {\r\n\r\n    /**\r\n     * Generate a Sparky Component that can be mount.\r\n     * @param renderFunc The function that going to be execute to render html template\r\n     */\r\n    static component(renderFunc: ISparkyFunction, props?: ISparkyProps) {\r\n        const sparkyContext = SparkyContext.newContext({ props, renderFunc });\r\n        return { type: \"SparkyComponent\", context: sparkyContext, currentContext: sparkyContext, renderFn: renderFunc } as ISparkyComponent;\r\n    }\r\n\r\n    /**\r\n     * Create a routing component that manage history\r\n     * @param stateRoute \r\n     */\r\n    static router(stateRoute: IStateRoute[], options?: ISparkyRouterOptions): ISparkyRouter {\r\n        if(!options) options = { type: \"hash\" };\r\n        let locationString = \"\";\r\n        if(options.type == \"hash\") {\r\n            locationString = location.hash.slice(2, location.hash.length);\r\n        } else if (options.type == \"browser\") {\r\n            locationString = location.pathname;\r\n        }\r\n        const routeState = getStateByHash(stateRoute, locationString);\r\n        routeState.hash = locationString;\r\n        let params = []\r\n        if(routeState.exact)\r\n            params = getParamsByPath(routeState.path, locationString);\r\n        return { type: \"SparkyRouter\", component: routeState.component, routing: stateRoute, history: [routeState], params, options };\r\n    }\r\n\r\n    /**\r\n     * Mount a Sparky Component in the DOM Tree and keep it updated.\r\n     * @param component Sparky Component\r\n     * @param dom The dom element where you want to mount this component\r\n     */\r\n    static mount(element: ISparkyComponent | ISparkyRouter, dom: HTMLElementSparkyEnhanced): ISparkySelf {\r\n        if (process.env.NODE_ENV === 'development')\r\n            console.time();\r\n        \r\n        const component = ((element.type == \"SparkyComponent\") ? element : (element as ISparkyRouter).component) as ISparkyComponent \r\n\r\n        initialiseDOM(dom, element);\r\n\r\n        const { context, renderFn } = component;\r\n\r\n        const keepIndexes = cloneDeep(component.currentContext.indexes);\r\n\r\n        context.__rootElement = dom; \r\n        SparkyContext.setCurrentContext(context);\r\n        SparkyContext.resetIndexes();\r\n\r\n        const render = renderFn(Object.freeze(context.props)) as IRenderReturn;\r\n\r\n        const oldDom = dom.__sparkyRoot.updateAt ? (dom.firstElementChild as HTMLElementSparkyEnhanced) : null;\r\n        let nextDOM = renderToDOMNode(render.html);\r\n\r\n        nextDOM = SparkyComponent.populate(nextDOM, render, component);\r\n\r\n\r\n        let finalDOM = reconciliate(oldDom, nextDOM);\r\n        if (!finalDOM) return;\r\n        if (!finalDOM.isConnected && dom)\r\n            dom.appendChild(finalDOM);\r\n\r\n        dom.__sparkyRoot.updateAt = new Date().getTime();\r\n\r\n        EventManager.listen(finalDOM);\r\n\r\n        if (process.env.NODE_ENV === 'development')\r\n            console.timeEnd();\r\n\r\n        if(typeof thisTest != \"undefined\" && thisTest.testing) {\r\n            thisTest.__testUtilData = {\r\n                root: dom,\r\n                component,\r\n                eventList: thisTestEvent\r\n            };\r\n        }\r\n        \r\n        return {...component.currentContext, indexes: keepIndexes};\r\n    }\r\n\r\n    /**\r\n     * Create a Store to using it on components\r\n     * @param newStore Object that will be Store\r\n     * @param dispatcher Function that will run for changing programatically store object\r\n     */\r\n    static createStore<S>(newStore: S, dispatcher: (state: S, action: IDispatcherAction) => S): ISparkyStore<S> {\r\n        return {\r\n            type: \"SparkyStore\",\r\n            store: newStore,\r\n            dispatcher: (store, action) => { store.store = dispatcher(store.store, action) }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Reconciliate the current DOM with the new DOM Node\r\n     * @internal\r\n     * @param oldNode Node that need to be reconcile\r\n     * @param newNode Node that have the new elements\r\n     */\r\n    static reconciliate(oldNode: HTMLElement, newNode: HTMLElement) {\r\n        return reconciliate(oldNode, newNode)\r\n    }\r\n}\r\n\r\n/**\r\n * Function will be run after the render is commited to the screen.\r\n * @param callbackFn - The function to run\r\n * @param dependenciesChanged - Array of values that the function depends on\r\n */\r\nexport const update = Sparky__update;\r\n\r\n/**\r\n * Returns a stateful value, and a function to update it.\r\n * @param initialState The value during the first render\r\n */\r\nexport const state = Sparky__state;\r\n\r\n/**\r\n * Run and returns a memoized value\r\n * @param callbackFn - Function will be run on rendering phase\r\n * @param argumentsChanged - Array of values that the function depends on\r\n */\r\nexport const memoize = Sparky__memoize;\r\n\r\n/**\r\n * Returns routing functions for current mounted component\r\n */\r\nexport const router = Sparky__internal_history;\r\n\r\n/**\r\n * Render the html string template to HTML elements\r\n * @param html Array of HTML String \r\n * @param computedProps Computed Props used to pass Javascript into template\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals\r\n */\r\nexport function html(html: TemplateStringsArray | string, ...computedProps: any[]): IRenderReturn {\r\n    const func: ISparkyEventFunc[] = [];\r\n    const nestedComponents: ISparkyComponent[] = [];\r\n    const children: IRenderReturn[] = [];\r\n    const renderId = nanoid(12);\r\n\r\n    const newHTML = (typeof html == \"string\") ? html\r\n        : html.map((stringHTML, i) => {\r\n            let htmlLine = \"\"\r\n            htmlLine += stringHTML\r\n            if (!computedProps[i]) return htmlLine;\r\n            htmlLine = getComputedValue(computedProps, i, func, htmlLine, nestedComponents, children, renderId);\r\n            return htmlLine;\r\n        })\r\n\r\n    const innerHTML = Array.isArray(newHTML) ? newHTML.join(\"\") : newHTML;\r\n\r\n    return { type: \"SparkyRender\", html: innerHTML, func, nestedComponents, children, renderId };\r\n}\r\n\r\n/**\r\n * @internal\r\n * @param computedProps \r\n * @param i \r\n * @param func \r\n * @param htmlLine \r\n * @param nestedComponents \r\n * @param children \r\n * @param renderId \r\n */\r\nfunction getComputedValue(computedProps: any[], i: number, func: ISparkyEventFunc[], htmlLine: string, nestedComponents: ISparkyComponent[], children: IRenderReturn[], renderId: string) {\r\n    if (typeof computedProps[i] == \"function\") {\r\n        func.push({ index: func.length - 1, renderId, func: computedProps[i] });\r\n        htmlLine += `'SparkyFunction#${renderId}#${func.length - 1}'`;\r\n    }\r\n    else if (computedProps[i].type == \"SparkyRender\") {\r\n        const render = computedProps[i] as IRenderReturn;\r\n        htmlLine += render.html;\r\n        children.push(render)\r\n    }\r\n    else if (computedProps[i].type == \"SparkyComponent\") {\r\n        const comp = computedProps[i] as ISparkyComponent;\r\n        htmlLine += `<!-- SparkyComponent#${comp.renderFn.name}#${nestedComponents.length}#${renderId} -->`;\r\n        nestedComponents.push(comp);\r\n    }\r\n    else {\r\n\r\n        computedProps[i] = Array.isArray(computedProps[i]) ?\r\n            computedProps[i].join(\"\") : new String(computedProps[i]);\r\n        if ((computedProps[i] as string).startsWith(\"<\"))\r\n            htmlLine += computedProps[i];\r\n        else\r\n            htmlLine += `<span class='computed'>${computedProps[i]}</span>`;\r\n    }\r\n    return htmlLine;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @param dom \r\n * @param element \r\n */\r\nfunction initialiseDOM(dom: HTMLElementSparkyEnhanced, element: ISparkyComponent | ISparkyRouter) {\r\n    if (dom && !dom.__sparkyRoot) {\r\n        setRootProperties(dom);\r\n        if (element.type == \"SparkyRouter\") {\r\n            const { history, routing, params, options } = element as ISparkyRouter;\r\n            dom.__sparkyRoot = { ...dom.__sparkyRoot, history, \r\n                routing, params, \r\n                basename: options?.basename, \r\n                isRoutingEnabled: true,\r\n                forceURLUpdate: options?.forceUrlUpdate,\r\n                type: options?.type\r\n            };\r\n            if(dom.__sparkyRoot.type == \"hash\") {\r\n                listeningHashChange(routing, (component) => {\r\n                    Sparky.mount(component, dom);\r\n                }, dom);                \r\n            }\r\n        }\r\n    }\r\n    ;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @param dom \r\n */\r\nfunction setRootProperties(dom: HTMLElementSparkyEnhanced) {\r\n    dom.__sparkyRoot = { \r\n        id: nanoid(12),\r\n        isRoutingEnabled: false,\r\n        basename: \"\",\r\n        params: [],\r\n        forceURLUpdate: false,\r\n        type: \"hash\",\r\n        historyIndex: 0,\r\n        stateChanging: false,\r\n        history: [],\r\n        routing: [],\r\n        updateAt: null\r\n    };\r\n}\r\n\r\n/**\r\n * @internal\r\n * @param html \r\n */\r\nexport function renderToDOMNode(html: string) {\r\n    const div = document.createElement(\"div\");\r\n    div.innerHTML = html;\r\n    if (div.children.length > 1) {\r\n        throw new TypeError(\"Adjacent elements on the root level are forbidden.\");\r\n    }\r\n    return div.firstElementChild as HTMLElement;\r\n}"],"names":["url","i","toString","toUpperCase","t","u","e","c","size","id","Math","random","reconciliate","currentDom","nextDom","isEqualNode","nodeName","domQueue","_a","currentElem","nextElem","removedList","attributes","sortedCurrentAttributes","Array","from","sort","attr","attr2","attributeSort","sortedNextAttributes","removedAttr","forEach","nextAttr","name","push","setAttribute","value","length","removeAttribute","reconciliateAttribute","__sparkyEvent","__sparkyRoot","nextElemChildren","childNodes","node","nextNode","item","textContent","newNextNode","cloneNode","oldNextNode","parentElement","replaceChild","childNode","appendChild","rmElem","removeChild","a","b","isConnectedPolyfill","Node","prototype","window","test","Object","defineProperty","get","this","ownerDocument","compareDocumentPosition","DOCUMENT_POSITION_DISCONNECTED","r","call","pow","n","Number","isNaN","isFinite","floor","abs","min","max","TypeError","arguments","o","f","find","EventManager","finalDOM","removeAllEvents","populateEvents","removeUnusedEvents","thisTestEvent","eventList","event","type","_this","isEventTypeListening","document","addEventListener","dispatchEvent","eventListType","evtList","isEventTarget","callbackFn","eventSingle","dom","context","elem","shift","addEvent","index","children","filter","evt","isConnected","target","contains","val","ctorName","isArray","constructor","isBuffer","callee","err","message","indexOf","isArguments","Date","toDateString","getDate","setDate","isDate","Error","stackTraceLimit","isError","RegExp","flags","ignoreCase","multiline","global","isRegexp","throw","return","next","isGeneratorObj","slice","toLowerCase","replace","isObjectObject","valueOf","Symbol","deep","typeOf","assign","Map","Set","len","buf","Buffer","allocUnsafe","copy","cloneBuffer","cloneSymbol","res","byteLength","Uint8Array","set","cloneArrayBuffer","buffer","byteOffset","cloneTypedArray","exec","re","source","lastIndex","cloneRegExp","create","cloneDeep","instanceClone","ctor","prot","hasOwnProperty","key","cloneObjectDeep","cloneArrayDeep","clone","emptyContext","__rootElement","__root","__id","props","state","cachedMemo","cachedUpdate","cachedState","indexes","memo","update","renderFunc","SparkyContext","__context","newContext","ReferenceError","__defaultContext","nanoid","callCachedFn","cachedArray","argumentsChanged","fnCached","getIndexByType","incrementIndexByType","array1","bigArray","smallArray","newMemo","fn","result","dependencies","array2","length_1","length_2","every","big","listeningHashChange","stateRoute","isRoutingEnabled","requestIdleCallback","changeStateByEvent","thisTest","testing","Event","writable","stateChanging","basename","forceURLUpdate","documentSparky","__sparkyRoutingId","console","warn","oldURL","newURL","newState","getStateByHash","location","hash","params","getParamsByPath","path","pushToAbstractHistory","component","newPath","exact","includes","split","pathPart","part","startsWith","join","matchUrl","sparkyRoot","historyIndex","history","Sparky_cleanHistory","Sparky__goToState","routing","routeState","normalizePath","pathname","Sparky","mount","Sparky__back","Sparky__forward","Sparky__params","Sparky__currentState","urlParts","reduce","obj","cb","start","now","setTimeout","didTimeout","timeRemaining","cancelIdleCallback","clearTimeout","getContext","currentContext","getCurrentContext","setCurrentState","setCurrentContext","resetIndexes","prevState","renderFn","Sparky__store","store","action","dispatcher","sparkyContext","options","locationString","element","process","env","NODE_ENV","time","initialiseDOM","keepIndexes","render","freeze","oldDom","updateAt","firstElementChild","nextDOM","renderToDOMNode","html","SparkyComponent","populate","getTime","listen","timeEnd","__testUtilData","root","newStore","oldNode","newNode","setRootProperties","history_1","forceUrlUpdate","div","createElement","innerHTML","String","substr","rootComponent","renderQueue","depthHorizontal","currentRender","currentComponent","currentDOM","this_1","cachedComponent","func","currentFunc","currentEvent","renderId","eventAttr","index_1","findEvent","eventName","currentChild","nestedComponents","currentComp","cached","commentDom","findComment","getCachedComponent","renderChild","renderChildDOM","parentNode","componentName","nodeValue","trim","i_1","dependenciesChanged","timeout","initialState","initialStore","bound","currentState","bind","setState","setInitialState","memoize","router","goToState","goBack","goAfter","getParams","cleanHistory","getCurrentState","getComputedValue","computedProps","htmlLine","comp","_i","newHTML","map","stringHTML"],"mappings":"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"}